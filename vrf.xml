<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc strict="no"?>
<?rfc rfcedstyle="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>

<rfc category="std" docName="draft-goldbe-vrf-01" ipr="trust200902">
    <front>
        <title abbrev="VRF">Verifiable Random Functions (VRFs)</title>

        <author fullname="Sharon Goldberg" initials="S." surname="Goldberg">
            <organization>Boston University</organization>
            <address>
                <postal>
                    <street>111 Cummington St, MCS135</street>
                    <city>Boston</city>
                    <region>MA</region>
                    <code>02215</code>
                    <country>USA</country>
                </postal>
                <email>goldbe@cs.bu.edu</email>
            </address>
        </author>

        <author fullname="Dimitrios Papadopoulos" initials="D." surname="Papadopoulos">
            <organization>University of Maryland</organization>
            <address>
                <postal>
                    <street>8223 Paint Branch Dr</street>
                    <city>College Park</city>
                    <region>MD</region>
                    <code>20740</code>
                    <country>USA</country>
                </postal>
                <email>dipapado@bu.edu</email>
            </address>
        </author>

        <author fullname="Jan Vcelak" initials="J." surname="Vcelak">
            <organization>NS1</organization>
            <address>
                <postal>
                    <street>16 Beaver St</street>
                    <city>New York</city>
                    <region>NY</region>
                    <code>10004</code>
                    <country>USA</country>
                </postal>
                <email>jvcelak@ns1.com</email>
            </address>
        </author>

        <date year="2017" />

        <!-- <workgroup></workgroup> -->

        <keyword>public key cryptography</keyword>
        <keyword>hashing</keyword>
        <keyword>authenticated denial</keyword>
        
    <abstract>

       <t>
        A Verifiable Random Function (VRF) is the public-key version of a
        keyed cryptographic hash. Only the holder of the private key
        can compute the hash, but anyone with public key
        can verify the correctness of the hash.    
        VRFs are useful for preventing enumeration of hash-based data structures.
        This document specifies several VRF constructions that are secure in
        the cryptographic random oracle model. One  VRF uses RSA and the other
        VRF uses Eliptic Curves (EC). 
        </t>

    </abstract>

</front>

<middle>

    <section title="Introduction" anchor="intro">

        <section title="Rationale">

    <t>
   A Verifiable Random Function
   (VRF) <xref target="MRV99"></xref> is the public-key version of a
   keyed cryptographic hash. Only the holder of the private VRF key
   can compute the hash, but anyone with corresponding public key
   can verify the correctness of the hash.
   </t>

   <t>
   A key application of the VRF is to provide privacy against 
   offline enumeration (e.g. dictionary attacks) on data  stored in a 
   hash-based data structure. 
   In this application, a Prover holds the VRF secret key and uses the VRF hashing to
   construct a hash-based data structure on the input data.

   Due to the nature of the VRF, only the Prover can answer queries
   about whether or not some data is stored in the data structure.  Anyone who
   knows the public VRF key can verify that the Prover has answered the queries
   correctly. However no offline inferences (i.e. inferences without querying
   the Prover) can be made about the data stored in the data strucuture.
   </t>

   <!--
   <t>
       VRFs are used for this purpose to prevent zone content enumeration in
       Domain Name System Security Extensions (DNSSEC) with NSEC5 Authenticated
       Denial of Existence <xref target="I-D.vcelak-nsec5"/>.
   </t>
   -->

   </section>
   
        <section title="Requirements">
            <t>
                The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
                "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
                document are to be interpreted as described in
                <xref target="RFC2119" />.
            </t>
        </section>
   
        <section title="Terminology">
                
            <t>
                The following terminology is used through this document:
            </t>

            <t>
                <list style="hanging">
                    <t hangText="SK:">
                        The private key for the VRF. 
                    </t>
                    <t hangText="PK:">
                        The public key for the VRF. 
                    </t>
                    <t hangText="alpha:">
                        The input to be hashed by the VRF. 
                    </t>
                    <t hangText="beta:">
                        The VRF hash output. 
                    </t>
                    <t hangText="pi:">
                        The VRF proof. 
                    </t>
                    <t hangText="Prover:">
                        The Prover holds the private VRF key SK.
                    </t>
                    <t hangText="Verifier:">
                        The Verifier holds the public VRF key PK.
                    </t>
                </list>
            </t>
        </section>
   
   </section>
   
   <section title="VRF Algorithms">
   
   <t>
   A VRF comes with a key generation algorithm that generates a public VRF 
   key PK and private VRF key SK. 
   </t>
   
   <t>
   A VRF hashes an input alpha using the private VRF key SK to obtain a VRF 
   hash output beta
    <list>
    <t> beta = VRF_hash(SK, alpha) </t>
    </list>
   The VRF_hash algorithm is deterministic, in 
   the sense that it always produces the same output beta given a 
   pair of inputs (SK, alpha).
      
   The private key SK is also used to construct a 
   proof pi that beta is the correct hash output 
   <list>
        <t>pi = VRF_prove(SK, alpha)</t>
   </list>
   The VRFs defined in this document allow anyone to deterministically
   obtain the VRF hash output beta directly from the proof value pi as
   <list>
   <t> beta = VRF_proof2hash(pi)</t>
   </list>
   Notice that this means that 
   <list>
   <t> VRF_hash(SK, alpha) = VRF_proof2hash(VRF_prove(SK, alpha))</t>
   </list>
   The proof pi allows a Verifier holding the public key PK 
   to verify that beta is the correct VRF hash of input alpha
   under key PK. Thus, the VRF also comes with an algorithm
   <list>
   <t>   VRF_verify(PK, alpha, pi)</t>
   </list>
   that outputs VALID if beta=VRF_proof2hash(pi) is correct 
   VRF hash of alpha under key PK, and outputs INVALID otherwise.
   </t>   
   </section>
   
   
   <section title="VRF Security Properties" anchor="secdef">
    
    <t> VRFs are designed to ensure the following security properties.
   </t>
   
   
   <section title= "Full Uniqueness or Trusted Uniqueness">
	
    <t> Uniqueness means that, for any fixed public
	VRF key and for any input alpha, there is a unique VRF
	output beta that can be proved to be valid.  Uniqueness must hold
    even for an adversarial Prover that knows the VRF secret key SK.
    </t>

    <t>
    "Full uniqueness" states that a computationally-bounded adversary cannot
	choose 
    a VRF public key PK, 
    a VRF input alpha, 
    two different VRF hash outputs beta1 and beta2, 
    and two proofs pi1 and pi2 such that 
    VRF_verify(PK, alpha, pi1)
    and VRF_verify(PK, alpha, pi2)
	both output VALID.
    </t>
    
    <t>
     A slightly weaker security
     property called "trusted uniquness" sufficies for many applications.
     Trusted uniqueness is the same as full uniqueness, but it must hold 
     only if the VRF keys PK and SK were generated in a trustworthy 
     manner. In otherwords, uniqueness might not hold if keys were 
     generated in an invalid manner or with bad randomness.
	</t>
	</section>

	<section title="Full Collison Resistance or Trusted Collision Resistance">

    <t>Like any cryprographic hash function, VRFs need to be
        collision resistant.  Collison resistance must hold
    even for an adversarial Prover that knows the VRF secret key SK.
    </t>
    
    <t> More percisely, "full collision resistance" states that
        it should be computationally 
        infeasible for an adversary to find two distinct VRF
	    inputs alpha1 and alpha2 that have the same VRF hash beta, 
        even if that adversary knows the secret VRF key SK.
    </t>
    
    <t>
	    For most applications, a slightly weaker security property
        called "trusted collision resistance" suffices. 
        Trusted collision resistance is the same as collision resistance, 
        but it holds only if PK and SK were generated in a trustworthy manner.
    </t>
   </section>


    <section title="Full Pseudorandomness or Selective Pseudorandomness">
    
    <t> Pseudorandomness ensures that when an adversarial Verifier sees 
        a VRF hash output beta without its corresponding VRF proof pi, 
        then beta is indistinguishable from a random value.
    </t>
    
    <t>  More percisely, suppose the public and private VRF keys (PK, SK) were generated
	     in a trustworthy manner.
	     Pseudorandomness ensures that the VRF hash output beta
         (without its corresponding VRF proof pi) on
	     any adversarially-chosen "target" VRF input alpha
	     looks indistinguishable from random
	     for any computationally bounded adversary who does not know the private
         VRF key SK.  This holds even if the adversary also gets to 
         choose other VRF inputs alpha' and observe their corresponding 
         VRF hash outputs beta' and proofs pi'.
    </t>
    
    <t>   
         With "full pseudorandomness", the adversary is allowed to choose the 
         "target" VRF input  alpha at any time, even after it observes VRF outputs beta'
         and proofs pi' on a variety of chosen inputs alpha'.
         </t>
         
         <t>
         "Selective pseudorandomness" is a weaker security property
         which suffices in many applications. Here, the adversary must choose
         the target VRF input alpha independently of the public VRF key PK,
         and before it  observes VRF outputs beta'
         and proofs pi' on inputs alpha' of its choice.
	     </t>
         
	<t> 
	   It is important to remember that the VRF output beta does not 
	   look random to the Prover, or to any other party that knows the private 
       VRF key SK!  Such a party can easily distinguish beta from 
       a random value by comparing beta to the result of VRF_hash(SK, alpha).	     
	</t>

	<t> Also, the VRF output beta does not look random to any party that
	knows valid VRF proof pi corresponding to the VRF input alpha, even
	if this party does not know the private VRF key SK.
	Such a party can easily distinguish beta from a random value by
    checking whether VRF_verify(PK, alpha, pi) returns "VALID" and
    beta = VRF_proof2hash(pi).
	</t>

    
	<t>
    Also, the VRF output beta may not look random if VRF key generation
    was not done in a trustworthy fashion. (For example, if VRF keys were 
    generated with bad randomness.)
	</t>

   </section>
   </section>
  
   
    <section title="RSA Full Domain Hash VRF (RSA-FDH-VRF)" anchor="fdh">
        <t>
            The RSA Full Domain Hash  VRF (RSA-FDH-VRF) is a VRF that satisfies
            the "trusted uniqueness", "trusted
            collision resistance", and "full pseudorandomness" properties defined in <xref target="secdef"/>.
            Its security follows from the
            standard RSA assumption in the random oracle model.  Formal
            security proofs are in <xref target="nsec5ecc" />.  
        </t>

        <t>
            The VRF computes the proof pi as a deterministic RSA signature on
            input alpha using the RSA Full Domain Hash Algorithm
            <xref target="RFC8017" /> parametrized with the selected hash algorithm.
            RSA signature verification is used to verify the correctness of the
            proof. The VRF hash output beta is simply obtained by hashing 
            the proof pi with the selected hash algorithm.
        </t>

        <t>
            The key pair for RSA-FDH-VRF MUST be generated in a way that it satisfies
            the conditions specified in Section 3 of <xref target="RFC8017" />.
        </t>

        <t>
            In this document, the notation from <xref target="RFC8017" /> is used.
        </t>

        <t>
            Parameters used:
            <list>
                <!-- do not change the names, these are from RFC8017 -->
                <t>(n, e) - RSA public key</t>
                <t>K - RSA private key</t>
                <t>k - length in octets of the RSA modulus n</t>
            </list>
        </t>

        <t>
            Fixed options:
            <list>
                <t>Hash - cryptographic hash function</t>
                <t>hLen - output length in octets of hash function Hash</t>
            </list>
        </t>

        <t>
            Constraints on options:
            <list>
                <t>Cryptographic security of Hash is at least as high as the cryptographic security level of the RSA key</t>
            </list>
        </t>

        <t>
            Primitives used:
            <list>
                <t>
                    I2OSP - Coversion of a nonnegative integer to an octet string as defined in
                    Section 4.1 of <xref target="RFC8017" />
                </t>
                <t>
                    OS2IP - Coversion of an octet string to a nonnegative integer as defined in
                    Section 4.2 of <xref target="RFC8017" />
                </t>
                <t>
                    RSASP1 - RSA signature primitive as defined in
                    Section 5.2.1 of <xref target="RFC8017" />
                </t>
                <t>
                    RSAVP1 - RSA verification primitive as defined in
                    Section 5.2.2 of <xref target="RFC8017" />
                </t>
                <t>
                    MGF1 - Mask Generation Function based on a hash function as defined in
                    Section B.2.1 of <xref target="RFC8017" />
                </t>
            </list>
        </t>

        <section title="RSA-FDH-VRF Proving">
            <t>
                RSAFDHVRF_prove(K, alpha)
            </t>

            <t>
                Input:
                <list>
                    <t>K - RSA private key</t>
                    <t>alpha - VRF hash input, an octet string</t>
                </list>
            </t>

            <t>
                Output:
                <list>
                    <t>pi - proof, an octet string of length k</t>
                </list>
            </t>

            <t>
                Steps:
                <list style="numbers">
                    <t>EM = MGF1(alpha, k - 1)</t>
                    <t>m = OS2IP(EM)</t>
                    <t>s = RSASP1(K, m)</t>
                    <t>pi = I2OSP(s, k)</t>
                    <t>Output pi</t>
                </list>
            </t>
        </section>
        
        <section title="RSA-FDH-VRF Proof To Hash">
            <t>
                RSAFDHVRF_proof2hash(pi)
            </t>

            <t>
                Input:
                <list>
                    <t>pi - proof, an octet string of length k</t>
                </list>
            </t>
            
            <t>
                Output:
                <list>
                    <t>beta - VRF hash output, an octet string of length hLen</t>
                </list>
            </t>

            <t>
                Steps:
                <list style="numbers">
                    <t>beta = Hash(pi)</t>
                    <t>Output beta</t>
                </list>
            </t>
        </section>

        <section title="RSA-FDH-VRF Verifying">
            <t>
                RSAFDHVRF_verify((n, e), alpha, pi)
            </t>

            <t>
                Input:
                <list>
                    <t>(n, e) - RSA public key</t>
                    <t>alpha - VRF hash input, an octet string</t>
                    <t>pi - proof to be verified, an octet string of length n</t>
                </list>
            </t>

            <t>
                Output:
                <list>
                    <t>"VALID" or "INVALID"</t>
                </list>
            </t>

            <t>
                Steps:
                <list style="numbers">
                    <t>s = OS2IP(pi)</t>
                    <t>m = RSAVP1((n, e), s)</t>
                    <t>EM = I2OSP(m, k - 1)</t>
                    <t>EM' = MGF1(alpha, k - 1)</t>
                    <t>
                        If EM and EM' are equal, output "VALID";
                        else output "INVALID".
                    </t>
                </list>
            </t>
        </section>
 
    </section>

    <section title="Elliptic Curve VRF (EC-VRF)" anchor="ecvrf">

    	<!--<t><cref source="Jan">We repeat these security properties here, 
            although we already said that all VRF functions are required 
            to satisfy these properties. What about removing it here and 
            keep just the rough description, reference to the 
            security proof?</cref>
            <cref source="Sharon">Relevant because of trusted / full / selective
            qualifiers of the security definitions. </cref>
        </t>-->
        
        <t>
            The Elliptic Curve Verifiable Random Function (EC-VRF) is a VRF that
            satisfies the trusted uniqueness, trusted collision resistance,
            and full pseudorandomness properties defined in <xref target="secdef"/>.
            The security of this VRF follows from the decisional 
            Diffie-Hellman (DDH) assumption in the random oracle model. Formal security proofs are
            in <xref target="nsec5ecc" />.  
        </t>

        <t>
            Fixed options:
            <list>
                <t>F - finite field</t>
                <t>2n - length, in octets, of a field element in F</t>
                <t>E - elliptic curve (EC) defined over F</t>
                <t>m - length, in octets, of an EC point encoded as an octet string</t> <!-- remove? -->
                <t>G - subgroup of E of large prime order</t>
                <t>q - prime order of group G</t>
                <t>cofactor - number of points on E divided by q</t>
                <t>g - generator of group G</t>
                <t>Hash - cryptographic hash function</t>
                <t>hLen - output length in octets of Hash</t>
            </list>
        </t>

        <t>
            Constraints on options:
            <list>
                <t>Field elements in F have bit lengths divisible by 16</t>
                <t>hLen is equal to 2n</t>
            </list>
        </t>

          <t>
            Parameters used:
            <list>
                <t>y = g^x - VRF public key, an EC point</t>
                <t>x - VRF private key, an integer where 0 &lt; x &lt; q
                <cref source="Sharon">check this with leo</cref></t> 
             </list>
        </t>

        <t>
            Notation and primitives used:
            <list>
                <t>p1*p2 - point addition, i.e. group operation on two EC points p1 and p2</t>
                <t>p^k - point multiplication, i.e. k repetitions of group operation on EC point p</t>
                <t>|| - octet string concatenation</t>
                <t>I2OSP - nonnegative integer conversion to octet string as defined in
                    Section 4.1 of <xref target="RFC8017" /></t>
                <t> OS2IP - Coversion of an octet string to a nonnegative integer as defined in
                    Section 4.2 of <xref target="RFC8017" /></t>
                <t>EC2OSP - conversion of EC point to an m-octet string 
                as specified in <xref target="suites"/></t>
                <t>OS2ECP - conversion of an m-octet string to EC point
                as specified in <xref target="suites"/>.
                OS2ECP returns INVALID if the octet string does not convert to a valid EC point.</t>
                <t>RS2ECP - conversion of a random 2n-octet string to an 
                EC point as specified in <xref target="suites"/></t>
            </list>
        </t>

        <section title="EC-VRF Proving" anchor="ecvrfprove">
            <t>
                ECVRF_prove(y, x, alpha)
            </t>

            <t>
                Input:
                <list>
                    <t>y - public key, an EC point</t>
                    <t>x - private key, an integer</t>
                    <t>alpha - VRF input, an octet string</t>
                </list>
            </t>

            <t>
                Output:
                <list>
                    <t>pi - VRF proof, octet string of length m+3n</t>
                </list>
            </t>

            <t>
                Steps:
                <list style="numbers">
                    <t>h = ECVRF_hash_to_curve(y, alpha)</t>
                    <t>gamma = h^x</t>
                    <t>choose a random integer nonce k from [0, q-1]</t>
                    <t>c = ECVRF_hash_points(g, h, y, h^x, g^k, h^k)</t>
                    <t>s = k - c*x mod q</t>
                    <t>pi = EC2OSP(gamma) || I2OSP(c, n) || I2OSP(s, 2n)</t>
                    <t>Output pi</t>
                </list>
            </t>
            
        </section>


        <section title="EC-VRF Proof To Hash">
            <t>
                ECVRF_proof2hash(pi)
            </t>
            <t>
                Input:
                <list>
                    <t>pi - VRF proof, octet string of length m+3n</t> 
                </list>
            </t>
            <t>
                Output:
                <list>
                    <t>"INVALID", or </t>
                    <t>beta - VRF hash output, octet string of length 2n</t>
                </list>
            </t>
            <t>
                Steps:
                <list style="numbers">
                    <t>D = ECVRF_decode_proof(pi)</t>
                    <t>If D is "INVALID", output "INVALID" and stop</t>
                    <t>(gamma, c, s) = D</t>
                    <t>beta = Hash(EC2OSP(gamma^cofactor))</t>
                    <t>Output beta</t>
                </list>
            </t>
        </section>

        <section title="EC-VRF Verifying">
            <t>
                ECVRF_verify(y, pi, alpha)
            </t>

            <t>
                Input:
                <list>
                    <t>y -  public key, an EC point</t>
                    <t>pi - VRF proof, octet string of length 5n+1</t>
                    <t>alpha - VRF input, octet string</t>
                </list>
            </t>

            <t>
                Output:
                <list>
                    <t>"VALID" or "INVALID"</t>
                </list>
            </t>

            <t>
                Steps:
                <list style="numbers">
                    <t>D = ECVRF_decode_proof(pi)</t>
                    <t>If D is "INVALID", output "INVALID" and stop</t>
                    <t>(gamma, c, s) = D</t>
                    <t>u = y^c * g^s</t>
                    <t>h = ECVRF_hash_to_curve(y, alpha)</t>
                    <t>v = gamma^c * h^s</t>
                    <t>c' = ECVRF_hash_points(g, h, y, gamma, u, v)</t>
                    <t>
                        If c and c' are equal, output "VALID";
                        else output "INVALID" 
                    </t>
                </list>
            </t>
        </section>


        <section title="EC-VRF Auxiliary Functions">

        <section title="EC-VRF Hash To Curve" anchor="ecvrfH2C">
        
            <t>The ECVRF_hash_to_curve algorithm takes in an octet string alpha
            and converts it to h, an EC point in G. </t>
            
            <section title="ECVRF_hash_to_curve1" anchor="ecvrfH2C1">
            
            <t>
            The following ECVRF_hash_to_curve1(y, alpha) algorithm
            implements ECVRF_hash_to_curve in a simple and
            generic way that works for any elliptic curve. 
            </t>
            
            <t>
            The running time of this algorithm depends on alpha. 
            For the ciphersuites specified 
            in <xref target="suites"/>, this algorithm 
            is expected to find a valid curve point after approximately two attempts 
            (i.e., when ctr=1) on average. See also <xref target="Icart09"/>.
            </t>
            
            <t>
            However, because the running time of algorithm depends on alpha, 
            this algorithm SHOULD be avoided in 
            applications where it is important that
            the VRF input alpha remain secret. 
            </t>
            
            <t>
                ECVRF_hash_to_curve1(y, alpha)
            </t>
            <t>
                Input:
                <list>
                    <t>alpha - value to be hashed, an octet string</t>
                    <t>y - public key, an EC point</t>
                </list>
            </t>
            <t>
                Output:
                <list>
                    <t>h - hashed value, a finite EC point in G</t>
                </list>
            </t>
            
            <t>
                Steps:
                <list style="numbers">
                    <t>ctr = 0</t>
                    <t>pk = EC2OSP(y)</t>
                    <t>h = "INVALID"</t>
                    <t>While h is "INVALID" or h is EC point at infinity:
                    <list style="letters">
                        <t>CTR = I2OSP(ctr, 4)</t>
                        <t>ctr = ctr + 1</t>
                        <t>attempted_hash = Hash(pk || alpha || CTR)</t>
                        <t>h = RS2ECP(attempted_hash)</t>
                        <t>If h is not "INVALID" and cofactor > 1, set h = h^cofactor</t>
                    </list></t>
                    <t>Output h</t>
                </list>
            </t>
            
            
            </section>
            
            
            <section title="ECVRF_hash_to_curve2">
            
            <t>For applications where VRF input alpha must be kept secret,
            the following ECVRF_hash_to_curve algorithm MAY be used to used as
            generic way to hash an octet string onto any elliptic curve.
            </t>
            
            <t>[TODO: If there interest, we could look into specifying the 
            generic deterministic time hash_to_curve algorithm from 
            <xref target="Icart09"/>.  Note also for the Ed25519 curve 
            (but not the P256 curve), the Elligator algorithm 
            could be used here.]
            </t>
            </section>
        </section>

        <section title="EC-VRF Hash Points">
                     
            <t>
                ECVRF_hash_points(p_1, p_2, ..., p_j)
            </t>
            <t>
                Input:
                <list>
                    <t>p_i - EC point in G</t>
                </list>
            </t>
            <t>
                Output:
                <list>
                    <t>h - hash value, integer between 0 and 2^(8n)-1</t>
                </list>
            </t>
            <t>
                Steps:
                <list style="numbers">
                    <t>P = empty octet string</t>
                    <t>for p_i in [p_1, p_2, ... p_j]:
                       <vspace/>P = P || EC2OSP(p_i)
                    </t>
                    <t>h1 = Hash(P)</t>
                    <t>h2 = first n octets of h1</t>
                    <t>h = OS2IP(h2)</t>
                    <t>Output h</t>
                </list>
            </t>
            
            
                   
        </section>

        <section title="EC-VRF Decode Proof">
            <t>
                ECVRF_decode_proof(pi)
            </t>
            <t>
                Input:
                <list>
                    <t>pi - VRF proof, octet string (m+3n octets)</t>
                </list>
            </t>
            <t>
                Output:
                <list>
                    <t>"INVALID", or </t>
                    <t>gamma - EC point</t>
                    <t>
                    c - integer between 0 and 2^(8n)-1
                    </t>
                    <t>
                    s - integer between 0 and 2^(16n)-1
                    </t>
                </list>
            </t>
            <t>
                Steps:
                <list style="numbers">
                    <t>let gamma', c', s' be pi split after m-th and m+n-th octet</t>
                    <t>gamma = OS2ECP(gamma')</t>
                    <t>if gamma = "INVALID" output "INVALID" and stop.</t>
                    <t>c = OS2IP(c')</t>
                    <t>s = OS2IP(s')</t>
                    <t>Output gamma, c, and s</t>
                </list>
            </t>
        </section>

        </section><!-- Auxiliary Functions -->

        <section title="EC-VRF Ciphersuites" anchor="suites">
                
        <t>This document defines EC-VRF-P256-SHA256 as follows: 
        <list style="symbols">
        <t>
            The EC group G is the NIST-P256 elliptic curve, with curve parameters
            as specified in <xref target="FIPS-186-3"></xref> (Section D.1.2.3) 
            and <xref target="RFC5114"></xref>  (Section 2.6). For this group,
            2n = 32 and cofactor = 1.
        </t>
        <t> The key pair generation primitive is specified in
            Section 3.2.1 of <xref target="SECG1" />. </t>
        
        <t>
            EC2OSP is specified in Section 2.3.3 of <xref target="SECG1" /> with point compression on.
            This implies m = 2n + 1 = 33.
        </t>
        
        <t> OS2ECP is specified in Section 2.3.4 of <xref target="SECG1" />.
        </t>
        
        <t> RS2ECP(h) = OS2ECP(0x02 || h). The input h is a 32-octet string
        and the output is either an EC point or "INVALID". </t>
        
        <t>
            The hash function Hash is SHA-256 as specified in <xref target="RFC6234"/>.
        </t>
        <t>
            The ECVRF_hash_to_curve function is as specified in <xref target="ecvrfH2C1"/>.
        </t>
        </list>
        </t>
        
        <t>This document defines EC-VRF-ED25519-SHA256 as follows: 
        <list style="symbols">
        <t>
            The EC group G is the Ed25519
            elliptic curve with parameters defined in Table 1 of
             <xref target="RFC8032"></xref>.       
            For this group, 2n = 32 and cofactor = 8.
        </t>
        <t> The key pair generation primitive is specified in Section 5.1.5 
        of <xref target="RFC8032" /></t>
        
        <t> EC2OSP is specified in Section 5.1.2 of <xref target="RFC8032" />. This implies m = 2n = 32.</t>
        
        <t> OS2ECP is specified in Section 5.1.3 of <xref target="RFC8032" />.
        </t>

        <t>RS2ECP is equivalent to OS2ECP.</t>

        <t>
            The hash function Hash is SHA-256 as specified in <xref target="RFC6234"/>.
        </t>
        <t>
            The ECVRF_hash_to_curve function is as specified in <xref target="ecvrfH2C1"/>.
        </t>
        </list>
        </t>
   
        <t>[TODO: Should we add an EC-VRF-ED25519-SHA256-Elligator
        ciphersuite where the Elligator hash function is used for ECVRF_hash-to-curve?]
        </t>
   
        <t>[TODO: Add an Ed448 ciphersuite?]</t>
        
        </section>

        <section title="When the EC-VRF Keys are Untrusted" anchor="keycheck">
        
        <t>The EC-VRF as specified above is a VRF that satisfies the 
        "trusted uniqueness", "trusted collision resistance", and 
        "full pseudorandomness" properties defined in <xref target="secdef"/>.
        This VRF can be modified to additionally satisfy "full uniqueness", 
        and "full collision resistance" by additionally requiring the Verifier to perform
        the following validation procedure upon receipt of the public 
        VRF key.  
        </t>
        
        <t>The Verifier MUST perform this validation procedure when the 
        entity that generated the public VRF key is untrusted. 
        The public key MUST NOT be used if this procedure returns "INVALID".</t>
                
        <t> This procedure supposes that the public key provided to the Verifier is an octet 
        string. The procedure returns "INVALID" if the public key in invalid. 
        Otherwise, it returns y, the public key as an EC point.
        </t>
        
        
        <section title="EC-VRF Validate Key">
      
            <t>
                ECVRF_validate_key(PK)
            </t>
            <t>
                Input:
                <list>
                    <t>PK - public key, an octet string</t>
                </list>
            </t>
            <t>
                Output:
                <list>
                    <t>"INVALID", or </t>
                    <t>y - public key, an EC point</t>
                </list>
            </t>
            <t>
                Steps:
                <list style="numbers">
                    <t>y = OS2ECP(PK)</t>
                    <t>If y is "INVALID", output "INVALID" and stop</t>
                    <t>If y^q is not an EC point at infinty, output "INVALID" and stop</t>
                    <t>Output y</t>
                </list>
            </t>
        
        </section>       
        </section><!-- Untrusted keys -->

    </section>
    
    
    <section title="Implementation Status" anchor="imp">
    
        <t>
            An implementation of the RSA-FDH-VRF (SHA-256) and EC-VRF-P256-SHA256 was 
            first developed
            as a part of the NSEC5 project <xref target="I-D.vcelak-nsec5" /> and is available
            at <eref target="http://github.com/fcelda/nsec5-crypto" />.
        </t>
    
    <t>
    The Key Transparency project at Google
    uses a VRF implemention that is almost identical to
    the EC-VRF-P256-SHA256 specified here, with a few minor changes
    including the use of SHA-512 instead of SHA-256. Its implementation
    is available <eref target="https://github.com/google/keytransparency/blob/master/core/vrf/vrf.go" />
    </t>
    
    
    <t>
    An implementation by Yahoo! of the EC-VRF specified in this draft is available at 
    <eref target="https://github.com/r2ishiguro/vrf"/>.
    </t>
    
    
    <t>
    An implementation of the EC-VRF is available as part of the 
    CONIKS implementation in Golang at 
    <eref target="https://github.com/coniks-sys/coniks-go/tree/master/crypto/vrf"/>.
    </t>
    
    
    <t>
    Open Whisper Systems also uses a VRF very similar to 
    EC-VRF-ED25519-SHA512-Elligator, called VXEdDSA, and specified here:
    <eref target="https://whispersystems.org/docs/specifications/xeddsa/" />
    </t> 
    </section>    


    <section title="Security Considerations" anchor="securitycons">


    <section title="Key Generation">

    <t>Applications that use the VRFs defined in this
    document MUST ensure that that the VRF key is generated correctly,
    using good randomness.
    </t>
    
    <t> Without good randomness, the "pseudorandomness"
    properties of the VRF may not hold. Note that it is not possible to guarantee 
    pseudorandomness in the face of adversarially generated VRF keys.  This is
    because an adversary can always use bad randomness to generate the VRF keys, 
    and thus, the VRF output may not be pseudorandom.
    </t>
    
    <t>The RSA-VRF statisfies the "trusted uniqueness" and "trusted collision resistance" properties
    as long as the VRF keys are generated correctly, with good randomness.
    These properties may not hold if the keys are generated adversarially  
    (e.g., if RSA is not permutation). Meanwhile, 
    the "full uniqueness" and "full collision resistance" are 
    properties that hold  even if VRF keys are generated by an adversary.
    The RSA-VRF defined in this document does not have these properties.
    However, if adversarial key generation is a concern, the
    RSA-VRF may be modifed to have these 
    properties by adding additional cryptographic checks
    that its public key has the right form.  These modifications are left for future specification.
    </t>

    
    <t>The EC-VRF as specified in <xref target="ecvrfprove"/>-<xref target="suites"/>
    statisfies the "trusted uniqueness" and "trusted collision resistance" properties
    as long as the VRF keys are generated correctly, with good randomness.
    If the Verifier trusts the VRF keys are generated correctly, it MAY use 
    the public key y as is.
    However, if the EC-VRF uses keys that could be generated adversarially, then the 
    the Verfier MUST perform the validation procedure ECVRF_validate_key(PK)
    (specified in <xref target="keycheck"/>)  upon receipt of the
    public key PK as an octet string.  If the validation procedure
    outputs "INVALID", then the public key MUST not be used.  
    Otherwise, the procedure will output a valid public key y, 
    and the EC-VRF with public key y satisfies the "full uniqueness" and 
    "full collision resistance" properties.
    </t>
    
    
    </section>


    <section title="Proper randomness for EC-VRF">

    <t>
    Applications that use the EC-VRF defined in this document MUST ensure
    that the random nonce k used in the ECVRF_prove algorithm is
    chosen with proper randomness. Otherwise, an adversary may be able to recover
    the private VRF key x (and thus break pseudorandomness of the VRF)
    after observing several valid VRF proofs pi.
    </t>

    </section>

    <section title="Timing attacks">
    
    <t>The EC-VRF_hash_to_curve algorithm defined in
    <xref target="ecvrfH2C1" /> SHOULD NOT be used in applications where
    the VRF input alpha is secret and is hashed by the VRF on-the-fly.
    This is because the EC-VRF_hash_to_curve algorithm's running time depends
    on the VRF input alpha, and thus creates a timing channel that
    can be used to learn information about alpha. 
    That said, for most inputs the amount of information obtained from
    such a timing attack is likely to be small (1 bit, on average), since the algorithm 
    is expected to find a valid curve point after only two attempts.  
    However, there might be inputs which cause the algorithm to make many attempts
    before it finds a valid curve point; for such inputs, the information leaked
    in a timing attack will be more than 1 bit. 
    </t>

    </section>
    
    <section title="Selective vs Full Pseudorandomness">
    
    <t><xref target="nsec5ecc"/> presents cryptographic reductions to an 
    underlying hard problem (e.g. Decisional Diffie Hellman for the EC-VRF, or the 
    standard RSA assumption for RSA-VRF) that prove the VRFs specificied in this 
    document possess full pseudorandomness
    as well as selective pseudorandomness. 
    However, the cryptographic reductions are tighter for selective
    pseudorandomness than for full pseudorandomness.  This means the 
    the VRFs have quantitavely stronger security 
    guarentees for selective pseudorandomness. 
    </t>
    
    <t> Applications that are concerned about tightness of cryptographic
    reductions therefore have two options.
    
    <list style="symbols">
    <t> They may choose to ensure that selective pseudorandomness is sufficient for
    the application. That is, that
	pseudorandomness of outputs matters only for inputs that are chosen
    independently of the VRF key. 
    </t>
    <t>If full pseudorandomness is required for the application, the application
    may increase
    security parameters to make up for the loose security reduction. 
    For RSA-FDH-VRF, this means increasing the RSA key length. For 
    EC-VRF, this means increasing the cryptographic strength of the EC group
    G. For both RSA-FDH-VRF and EC-VRF the cryptographic strength of the 
    hash function Hash may also potentially need to be increased.
    </t>
    </list>
    </t>
    </section>

    </section>


    <section title="Change Log">
        <t>
            Note to RFC Editor: if this document does not obsolete an existing RFC,
            please remove this appendix before publication as an RFC.
        </t>

        <t>
            <list>
                <t>
                    00 - Forked this document from draft-vcelak-nsec5-04. 
                    Cleaned up the definitions of VRF algorithms.
                    Added security definitions for VRF and security considerations.
                    Parameterized EC-VRF so it could support curves other than 
                    P-256 and Ed25519.
                </t>
                <t>
                    01 - Fixed ECVRF to work when cofactor > 1.  
                    Changed ECVRF_proof2hash(pi) so that it outputs a value raised
                    to the cofactor and then processed by the cryptographic hash function Hash. 
                    Included the VRF public key y as input to the hash function
                    ECVRF_hash_to_curve1.
                    Cleaned up ciphersuites and ECVRF description so that it works with
                    EC point encodings for both P256 and Ed25519 curves.
                    Added ECVRF_validate_key so that EC-VRF can satisfy "full
                    uniqueness" and "full collision" resistance.
                    Updated implementation status.
                </t>
            </list>
        </t>
    </section>

    <section title="Contributors">
        <t>
            Leonid Reyzin (Boston University) is a major contributer to this 
            document. </t>
            
        <t>
            This document also would not be possible without the work of
            Moni Naor (Weizmann Institute),
            Sachin Vasant (Cisco Systems), and
            Asaf Ziv (Facebook).
            Shumon Huque (Salesforce) and David C. Lawerence (Akamai) provided
            valuable input to this draft.
        </t>
    </section>

</middle>

<back>
    <!-- References Section -->

<!--
     Section 4.7f of [RFC2223bis] specifies the requirements for the
     references sections.  In particular, there MUST be separate lists of
     normative and informative references, each in a separate section.
     The style SHOULD follow that of recently published RFCs.

     In general, each normative reference SHOULD reference the most recent
     version of the specification in question.
-->

    <references title="Normative References">
        <?rfc include="reference.RFC.2119.xml"?>
        <?rfc include="reference.RFC.8017.xml"?>
        <?rfc include="reference.RFC.5114.xml"?>
        <?rfc include="reference.RFC.6234.xml"?>
        <?rfc include="reference.RFC.8032.xml"?>
        
        <reference anchor="FIPS-186-3">
            <front>
                <title>Digital Signature Standard (DSS)</title>
                <author><organization>National Institute for Standards and Technology</organization></author>
                <date year="2009" month="June" />
            </front>
            <seriesInfo name="FIPS" value="PUB 186-3" />
        </reference>

        <reference anchor="SECG1" target="http://www.secg.org/sec1-v2.pdf">
            <front>
                <title>SEC 1: Elliptic Curve Cryptography</title>
                <author><organization>Standards for Efficient Cryptography Group (SECG)</organization></author>
                <date year="2009" month="May" />
            </front>
            <seriesInfo name="Version" value="2.0" />
        </reference>

    </references>

    <references title="Informative References">

        <reference anchor="nsec5ecc" target="https://eprint.iacr.org/2017/099.pdf">
            <front>
                <title>Making NSEC5 Practical for DNSSEC Deployments</title>
                <author initials="D." surname="Papadopoulos"><organization /></author>
                <author initials="D." surname="Wessels"><organization /></author>
                <author initials="S." surname="Huque"><organization /></author>
                <author initials="J." surname="Vcelak"><organization /></author>
                <author initials="M." surname="Naor"><organization /></author>
                <author initials="L." surname="Reyzin"><organization /></author>
                <author initials="S." surname="Goldberg"><organization /></author>
                <date year="2017" month="February" />
            </front>
            <seriesInfo name="in" value="ePrint Cryptology Archive 2017/099" />
        </reference>

        <reference anchor="MRV99">
            <front>
                <title>Verifiable Random Functions</title>
                <author initials="S." surname="Michali"><organization /></author>
                <author initials="M." surname="Rabin"><organization /></author>
                <author initials="S." surname="Vadhan"><organization /></author>
                <date year="1999" />
            </front>
            <seriesInfo name="in" value="FOCS" />
        </reference>

        <reference anchor="Icart09">
            <front>
                <title>How to Hash into Elliptic Curves</title>
                <author initials= "T." surname="Icart"><organization /></author>
                <date year="2009" />
            </front>
            <seriesInfo name="in" value="CRYPTO" />
        </reference>
        
        <?rfc include="reference.I-D.vcelak-nsec5.xml"?>

        
    </references>


    <section title="Open Issues">
        <t>
            Note to RFC Editor: please remove this appendix before publication as an RFC.
        </t>

        <t>
            <list style="numbers">
                <t>Open issues</t>
            </list>
        </t>
    </section>
  </back>
</rfc>
<!-- vim: et ts=4 sts=4 sw=4 colorcolumn=100 spell :
-->
