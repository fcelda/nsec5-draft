<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc strict="no"?>
<?rfc rfcedstyle="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>

<rfc category="std" docName="draft-irtf-cfrg-vrf-02" ipr="trust200902">
    <front>
        <title abbrev="VRF">Verifiable Random Functions (VRFs)</title>

        <author fullname="Sharon Goldberg" initials="S." surname="Goldberg">
            <organization>Boston University</organization>
            <address>
                <postal>
                    <street>111 Cummington St, MCS135</street>
                    <city>Boston</city>
                    <region>MA</region>
                    <code>02215</code>
                    <country>USA</country>
                </postal>
                <email>goldbe@cs.bu.edu</email>
            </address>
        </author>

        
        <author fullname="Leonid Reyzin" initials="L." surname="Reyzin">
            <organization>Boston University</organization>
            <address>
                <postal>
                    <street>111 Cummington St, MCS135</street>
                    <city>Boston</city>
                    <region>MA</region>
                    <code>02215</code>
                    <country>USA</country>
                </postal>
                <email>reyzin@bu.edu</email>
            </address>
        </author>


        <author fullname="Dimitrios Papadopoulos" initials="D." surname="Papadopoulos">
            <organization>Hong Kong University of Science and Techology</organization>
            <address>
                <postal>
                    <street>Clearwater Bay</street>
                    <!--<city></city>-->
                    <!--<region>MD</region>-->
                    <!--<code>20740</code>-->
                    <country>Hong Kong</country>
                </postal>
                <email>dipapado@cse.ust.hkbu.edu</email>
            </address>
        </author>

        <author fullname="Jan Vcelak" initials="J." surname="Vcelak">
            <organization>NS1</organization>
            <address>
                <postal>
                    <street>16 Beaver St</street>
                    <city>New York</city>
                    <region>NY</region>
                    <code>10004</code>
                    <country>USA</country>
                </postal>
                <email>jvcelak@ns1.com</email>
            </address>
        </author>

        <date year="2018" />

        <workgroup>CFRG</workgroup>

        <keyword>public key cryptography</keyword>
        <keyword>hashing</keyword>
        <keyword>authenticated denial</keyword>
        
    <abstract>

       <t>
        A Verifiable Random Function (VRF) is the public-key version of a
        keyed cryptographic hash. Only the holder of the private key
        can compute the hash, but anyone with public key
        can verify the correctness of the hash.    
        VRFs are useful for preventing enumeration of hash-based data structures.
        This document specifies several VRF constructions that are secure in
        the cryptographic random oracle model. One  VRF uses RSA and the other
        VRF uses Eliptic Curves (EC). 
        </t>

    </abstract>

</front>

<middle>

    <section title="Introduction" anchor="intro">

        <section title="Rationale">

    <t>
   A Verifiable Random Function
   (VRF) <xref target="MRV99"></xref> is the public-key version of a
   keyed cryptographic hash. Only the holder of the private VRF key
   can compute the hash, but anyone with corresponding public key
   can verify the correctness of the hash.
   </t>

   <t>
   A key application of the VRF is to provide privacy against 
   offline enumeration (e.g. dictionary attacks) on data  stored in a 
   hash-based data structure. 
   In this application, a Prover holds the VRF private key and uses the VRF hashing to
   construct a hash-based data structure on the input data.

   Due to the nature of the VRF, only the Prover can answer queries
   about whether or not some data is stored in the data structure.  Anyone who
   knows the public VRF key can verify that the Prover has answered the queries
   correctly. However no offline inferences (i.e. inferences without querying
   the Prover) can be made about the data stored in the data strucuture.
   </t>

   <!--
   <t>
       VRFs are used for this purpose to prevent zone content enumeration in
       Domain Name System Security Extensions (DNSSEC) with NSEC5 Authenticated
       Denial of Existence <xref target="I-D.vcelak-nsec5"/>.
   </t>
   -->

   </section>
   
        <section title="Requirements">
            <t>
                The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
                "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
                document are to be interpreted as described in
                <xref target="RFC2119" />.
            </t>
        </section>
   
        <section title="Terminology">
                
            <t>
                The following terminology is used through this document:
            </t>

            <t>
                <list style="hanging">
                    <t hangText="SK:">
                        The private key for the VRF. 
                    </t>
                    <t hangText="PK:">
                        The public key for the VRF. 
                    </t>
                    <t hangText="alpha:">
                        The input to be hashed by the VRF. 
                    </t>
                    <t hangText="beta:">
                        The VRF hash output. 
                    </t>
                    <t hangText="pi:">
                        The VRF proof. 
                    </t>
                    <t hangText="Prover:">
                        The Prover holds the private VRF key SK and public VRF key PK.
                    </t>
                    <t hangText="Verifier:">
                        The Verifier holds the public VRF key PK.
                    </t>
                </list>
            </t>
        </section>
   
   </section>
   
   <section title="VRF Algorithms">
   
   <t>
   A VRF comes with a key generation algorithm that generates a public VRF 
   key PK and private VRF key SK. 
   </t>
   
   <t>
   The prover hashes an input alpha using the private VRF key SK to obtain a VRF
   hash output beta
    <list>
    <t> beta = VRF_hash(SK, alpha) </t>
    </list>
   The VRF_hash algorithm is deterministic, in 
   the sense that it always produces the same output beta given a 
   pair of inputs (SK, alpha).
      
   The prover also uses the private key SK to construct a
   proof pi that beta is the correct hash output 
   <list>
        <t>pi = VRF_prove(SK, alpha)</t>
   </list>
   The VRFs defined in this document allow anyone to deterministically
   obtain the VRF hash output beta directly from the proof value pi as
   <list>
   <t> beta = VRF_proof2hash(pi)</t>
   </list>
   Notice that this means that 
   <list>
   <t> VRF_hash(SK, alpha) = VRF_proof2hash(VRF_prove(SK, alpha))</t>
   </list>
   and thus this document will specify VRF_prove and VRF_proof2hash
   rather than VRF_hash.
   </t>
   
   <t>
   The proof pi allows a Verifier holding the public key PK
   to verify that beta is the correct VRF hash of input alpha
   under key PK. Thus, the VRF also comes with an algorithm
   <list>
   <t>   VRF_verify(PK, alpha, pi)</t>
   </list>
   that outputs VALID if beta=VRF_proof2hash(pi) is the correct 
   VRF hash of alpha under key PK, and outputs INVALID otherwise.
   </t>   
   </section>
   
   
   <section title="VRF Security Properties" anchor="secdef">
    
    <t> VRFs are designed to ensure the following security properties.
   </t>
   
   
   <section title= "Full Uniqueness or Trusted Uniqueness">
	
    <t> Uniqueness means that, for any fixed public
	VRF key and for any input alpha, there is a unique VRF
	output beta that can be proved to be valid.  Uniqueness must hold
    even for an adversarial Prover that knows the VRF private key SK.
    </t>

    <t>
    More precisely, "full uniqueness" states that a computationally-bounded adversary cannot
	choose 
    a VRF public key PK, 
    a VRF input alpha, 
    two different VRF hash outputs beta1 and beta2, 
    and two proofs pi1 and pi2 such that 
    VRF_verify(PK, alpha, pi1)
    and VRF_verify(PK, alpha, pi2)
	both output VALID.
    </t>
    
    <t>
     A slightly weaker security
     property called "trusted uniqueness" sufficies for many applications.
     Trusted uniqueness is the same as full uniqueness, but it must hold 
     only if the VRF keys PK and SK were generated in a trustworthy 
     manner. In other words, uniqueness might not hold if keys were
     generated in an invalid manner or with bad randomness.
	</t>
	</section>

	<section title="Full Collison Resistance or Trusted Collision Resistance">

    <t>Like any cryprographic hash function, VRFs need to be
        collision resistant.  Collison resistance must hold
    even for an adversarial Prover that knows the VRF private key SK.
    </t>
    
    <t> More precisely, "full collision resistance" states that
        it should be computationally 
        infeasible for an adversary to find two distinct VRF
	    inputs alpha1 and alpha2 that have the same VRF hash beta, 
        even if that adversary knows the private VRF key SK.
    </t>
    
    <t>
	    For most applications, a slightly weaker security property
        called "trusted collision resistance" suffices. 
        Trusted collision resistance is the same as collision resistance, 
        but it holds only if PK and SK were generated in a trustworthy manner.
    </t>
   </section>


    <section title="Full Pseudorandomness or Selective Pseudorandomness" anchor="pseudodef">
    
    <t> Pseudorandomness ensures that when an adversarial Verifier sees 
        a VRF hash output beta without its corresponding VRF proof pi, 
        then beta is indistinguishable from a random value.
    </t>
    
    <t>  More precisely, suppose the public and private VRF keys (PK, SK) were generated
	     in a trustworthy manner.
	     Pseudorandomness ensures that the VRF hash output beta
         (without its corresponding VRF proof pi) on
	     any adversarially-chosen "target" VRF input alpha
	     looks indistinguishable from random
	     for any computationally bounded adversary who does not know the private
         VRF key SK.  This holds even if the adversary also gets to 
         choose other VRF inputs alpha' and observe their corresponding 
         VRF hash outputs beta' and proofs pi'.
    </t>
    
    <t>   
         With "full pseudorandomness", the adversary is allowed to choose the 
         "target" VRF input  alpha at any time, even after it observes VRF outputs beta'
         and proofs pi' on a variety of chosen inputs alpha'.
         </t>
         
         <t>
         "Selective pseudorandomness" is a weaker security property
         which suffices in many applications. Here, the adversary must choose
         the target VRF input alpha independently of the public VRF key PK,
         and before it  observes VRF outputs beta'
         and proofs pi' on inputs alpha' of its choice.
	     </t>
         
	<t> 
	   It is important to remember that the VRF output beta does not 
	   look random to the Prover, or to any other party that knows the private 
       VRF key SK!  Such a party can easily distinguish beta from 
       a random value by comparing beta to the result of VRF_hash(SK, alpha).	     
	</t>

	<t> Also, the VRF output beta does not look random to any party that
	knows valid VRF proof pi corresponding to the VRF input alpha, even
	if this party does not know the private VRF key SK.
	Such a party can easily distinguish beta from a random value by
    checking whether VRF_verify(PK, alpha, pi) returns "VALID" and
    beta = VRF_proof2hash(pi).
	</t>

    
	<t>
    Also, the VRF output beta may not look random if VRF key generation
    was not done in a trustworthy fashion. (For example, if VRF keys were 
    generated with bad randomness.)
	</t>

   </section>
   
   <section title="An additional pseudorandomness property">
   
   <t>[TODO:   This property is not needed for applications
   that use VRFs to prevent enumeration of hash-based data structures.
   However, we noticed that some other applications of VRF 
   (e.g. Algorand, Oroborus) rely on 
   this property.  We are waiting on a formal definition 
   of this property in the literature, and a proof that our ECVRF scheme
   can satisfy this property. 
   Preliminary analysis suggests that acheiving this property
   requires ECVRF verifiers to run an VRF_validate_key() key function upon receipt
   of VRF public keys and the proof2hash function to be modified to take in
   (gamma, beta, pk) rather than just gamma.]</t>
      
   <t>Pseudorandomness, as defined in <xref target="pseudodef"/>, does not 
   hold if the VRF keys were generated adversarially.
   </t>
   
   <t>There is, however, a different type of pseudorandomness that could hold 
   even if the VRF keys are generated adversarially, as long as 
   the VRF input alpha is unpredictable.  This property is similar
   to the pseudorandomness achieved by an (ordinary, unkeyed)
   cryptographic hash function.
   </t>
   
   <t>[TODO: Formal definition here.]</t>
   </section>
  
   </section>
   
    <section title="RSA Full Domain Hash VRF (RSA-FDH-VRF)" anchor="fdh">
        <t>
            The RSA Full Domain Hash  VRF (RSA-FDH-VRF) is a VRF that satisfies
            the "trusted uniqueness", "trusted
            collision resistance", and "full pseudorandomness" properties defined in <xref target="secdef"/>.
            Its security follows from the
            standard RSA assumption in the random oracle model.  Formal
            security proofs are in <xref target="nsec5ecc" />.  
        </t>

        <t>
            The VRF computes the proof pi as a deterministic RSA signature on
            input alpha using the RSA Full Domain Hash Algorithm
            <xref target="RFC8017" /> parametrized with the selected hash algorithm.
            RSA signature verification is used to verify the correctness of the
            proof. The VRF hash output beta is simply obtained by hashing 
            the proof pi with the selected hash algorithm.
        </t>

        <t>
            The key pair for RSA-FDH-VRF MUST be generated in a way that it satisfies
            the conditions specified in Section 3 of <xref target="RFC8017" />.
        </t>

        <t>
            In this document, the notation from <xref target="RFC8017" /> is used.
        </t>

        <t>
            Parameters used:
            <list>
                <!-- do not change the names, these are from RFC8017 -->
                <t>(n, e) - RSA public key</t>
                <t>K - RSA private key</t>
                <t>k - length in octets of the RSA modulus n</t>
            </list>
        </t>

        <t>
            Fixed options:
            <list>
                <t>Hash - cryptographic hash function</t>
                <t>hLen - output length in octets of hash function Hash</t>
            </list>
        </t>

        <t>
            Constraints on options:
            <list>
                <t>Cryptographic security of Hash is at least as high as the 
                cryptographic security level of the RSA key.</t>
            </list>
        </t>

        <t>
            Primitives used:
            <list>
                <t>
                    I2OSP - Conversion of a nonnegative integer to an octet string as defined in
                    Section 4.1 of <xref target="RFC8017" />
                </t>
                <t>
                    OS2IP - Conversion of an octet string to a nonnegative integer as defined in
                    Section 4.2 of <xref target="RFC8017" />
                </t>
                <t>
                    RSASP1 - RSA signature primitive as defined in
                    Section 5.2.1 of <xref target="RFC8017" />
                </t>
                <t>
                    RSAVP1 - RSA verification primitive as defined in
                    Section 5.2.2 of <xref target="RFC8017" />
                </t>
                <t>
                    MGF1 - Mask Generation Function based on a hash function as defined in
                    Section B.2.1 of <xref target="RFC8017" />
                </t>
            </list>
        </t>

        <section title="RSA-FDH-VRF Proving">
            <t>
                RSAFDHVRF_prove(K, alpha)
            </t>

            <t>
                Input:
                <list>
                    <t>K - RSA private key</t>
                    <t>alpha - VRF hash input, an octet string</t>
                </list>
            </t>

            <t>
                Output:
                <list>
                    <t>pi - proof, an octet string of length k</t>
                </list>
            </t>

            <t>
                Steps:
                <list style="numbers">
                    <t>EM = MGF1(alpha, k - 1)</t>
                    <t>m = OS2IP(EM)</t>
                    <t>s = RSASP1(K, m)</t>
                    <t>pi = I2OSP(s, k)</t>
                    <t>Output pi</t>
                </list>
            </t>
        </section>
        
        <section title="RSA-FDH-VRF Proof To Hash">
            <t>
                RSAFDHVRF_proof2hash(pi)
            </t>

            <t>
                Input:
                <list>
                    <t>pi - proof, an octet string of length k</t>
                </list>
            </t>
            
            <t>
                Output:
                <list>
                    <t>beta - VRF hash output, an octet string of length hLen</t>
                </list>
            </t>

            <t>
                Steps:
                <list style="numbers">
                    <t>beta = Hash(pi)</t>
                    <t>Output beta</t>
                </list>
            </t>
        </section>

        <section title="RSA-FDH-VRF Verifying">
            <t>
                RSAFDHVRF_verify((n, e), alpha, pi)
            </t>

            <t>
                Input:
                <list>
                    <t>(n, e) - RSA public key</t>
                    <t>alpha - VRF hash input, an octet string</t>
                    <t>pi - proof to be verified, an octet string of length n</t>
                </list>
            </t>

            <t>
                Output:
                <list>
                    <t>"VALID" or "INVALID"</t>
                </list>
            </t>

            <t>
                Steps:
                <list style="numbers">
                    <t>s = OS2IP(pi)</t>
                    <t>m = RSAVP1((n, e), s)</t>
                    <t>EM = I2OSP(m, k - 1)</t>
                    <t>EM' = MGF1(alpha, k - 1)</t>
                    <t>
                        If EM and EM' are equal, output "VALID";
                        else output "INVALID".
                    </t>
                </list>
            </t>
        </section>
 
    </section>

    <section title="Elliptic Curve VRF (ECVRF)" anchor="ecvrf">
        
        <t>
            The Elliptic Curve Verifiable Random Function (ECVRF) is a VRF that
            satisfies the trusted uniqueness, trusted collision resistance,
            and full pseudorandomness properties defined in <xref target="secdef"/>.
            The security of this VRF follows from the decisional 
            Diffie-Hellman (DDH) assumption in the random oracle model. Formal security proofs are
            in <xref target="nsec5ecc" />.  
        </t>
        
        <t> To additionally satisfy "full uniqueness" and "full collision resistance", 
        the Verifier MUST additionally perform the validation procedure specified in 
        <xref target="keycheck"/>  upon receipt of the public
        VRF key.
        </t>
        
        <t>
            Fixed options (specified in <xref target="suites"/>):
            <list>
                <t>F - finite field</t>
                <t>2n - length, in octets, of a field element in F; must be even</t>
                <t>E - elliptic curve (EC) defined over F</t>
                <t>m - length, in octets, of an EC point encoded as an octet string</t> <!-- remove? -->
                <t>G - subgroup of E of large prime order</t>
                <t>q - prime order of group G; must be less than 2^{2n}</t>
                <t>cofactor - number of points on E divided by q</t>
                <t>g - generator of group G</t>
                <t>Hash - cryptographic hash function</t>
                <t>hLen - output length in octets of Hash; must be at least 2n</t>
                <t>suite_string - a single nonzero octet specifying the ECVRF 
                ciphersuite, which determines the above options</t>
            </list>

        </t>
        
        <t>
            Notation and primitives used:
            <list>
                <!--<t>p1*p2 - point addition for EC points p1 and p2, i.e. group operation on two EC points p1 and p2</t>-->
                <t>p^k - When p is an EC point: point multiplication, i.e. k repetitions of the EC group operation applied to the EC point p. When p is an integer: exponentiation </t>
                <t>|| - octet string concatenation</t>
                <t>ECVRF_hash_to_curve - collision resistant hash of strings
                    to an EC point; options described in <xref target="ecvrfH2C" /> and specified in <xref target="suites"/>.</t>
                <t>ECVRF_nonce_generation - derives a pseudorandom nonce
                    from SK and the input as part of ECVRF proving.
                    Specified in <xref target="suites"/></t>
                <t>ECVRF_hash_points - collision resistant hash of EC points
                    to an n-octet string. Specified in <xref target="ecvrfHashPoints"/>.</t>
            </list>
        </t>
        <t>
            Type conversions:
            <list>
                <t>int_to_string(a, len) - conversion of nonnegative integer a to 
                to octet string of length len as specified in <xref target="suites"/>.</t>
                <t> string_to_int(a_string) - conversion of an octet string a_string
                to a nonnegative integer as specified in <xref target="suites"/>.</t>
                <t>point_to_string - conversion of EC point to an m-octet string
                    as specified in <xref target="suites"/></t>
                <t>string_to_point - conversion of an m-octet string to EC point
                    as specified in <xref target="suites"/>.
                    string_to_point returns INVALID if the octet string does not convert to a valid EC point.</t>
                <t>rand_string_to_point - conversion of a random 2n-octet string to an
                    EC point as specified in <xref target="suites"/></t>
            </list>
        </t>    

          <t>
            Parameters used (the generation of these parameters is specified in <xref target="suites"/>):
            <list>
                <t>SK - VRF private key</t>
                <t>x - VRF secret scalar, an integer
                    <list><t>
                        Note: depending on the ciphersuite used, the VRF secret scalar may be equal
                        to SK; else, it is derived from SK
                    </t></list>
                </t>
                <t>y = g^x - VRF public key, an EC point</t>
             </list>
        </t>


        <section title="ECVRF Proving" anchor="ecvrfprove">
                
                <t>
                    Note: this function must have the VRF private key SK as input. 
                    Below we make it more
                    efficient by supplying it also with the secret scalar x and the public key y as 
                    additional inputs; however, each of these can be computed from SK if desired.
                </t>
                
            <t>
                ECVRF_prove(y, x, alpha_string)
            </t>

            <t>
                Input:
                <list>
                    <t>SK - VRF private key</t>
                    <t>x - VRF secret scalar</t>
                    <t>y = g^x - VRF public key</t>
                    <t>alpha_string = input alpha, an octet string</t>
                </list>
            </t>

            <t>
                Output:
                <list>
                    <t>pi_string - VRF proof, octet string of length m+3n</t>
                </list>
            </t>

            <t>
                Steps:
                <list style="numbers">
                    <t>h = ECVRF_hash_to_curve(suite_string, y, alpha_string)</t>
                    <t>h_string = point_to_string(h)</t>
                    <t>gamma = h^x</t>
                    <t>k = ECVRF_nonce_generation(SK, h_string)</t>
                    <t>c = ECVRF_hash_points(h, gamma, g^k, h^k)</t>
                    <t>s = (k + c*x) mod q (where * denotes integer multiplication)</t>
                    <t>pi_string = point_to_string(gamma) || int_to_string(c, n) || int_to_string(s, 2n)</t>
                    <t>Output pi_string</t>
                </list>
            </t>
            
        </section>


        <section title="ECVRF Proof To Hash">
            <t>
                ECVRF_proof2hash(pi_string)
            </t>
            <t>
                Input:
                <list>
                    <t>pi_string - VRF proof, octet string of length m+3n</t> 
                </list>
            </t>
            <t>
                Output:
                <list>
                    <t>"INVALID", or </t>
                    <t>beta_string - VRF hash output, octet string of length 2n</t>
                </list>
            </t>
            <t>
                Steps:
                <list style="numbers">
                    <t>D = ECVRF_decode_proof(pi)</t>
                    <t>If D is "INVALID", output "INVALID" and stop</t>
                    <t>(gamma, c, s) = D</t>
                    <t>three_string = 0x03 = int_to_string(3, 1), a single octet with value 3 </t>
                    <t>b_string = Hash(suite_string || three_string || point_to_string(gamma^cofactor))</t>
                    <t>beta_string = first 2n octets of b_string</t>
                    <t>Output beta_string</t>
                </list>
            </t>
        </section>

        <section title="ECVRF Verifying">
            <t>
                ECVRF_verify(y, pi_string, alpha_string)
            </t>

            <t>
                Input:
                <list>
                    <t>y -  public key, an EC point</t>
                    <t>pi_string - VRF proof, octet string of length m+3n</t>
                    <t>alpha_string - VRF input, octet string</t>
                </list>
            </t>

            <t>
                Output:
                <list>
                    <t>"VALID" or "INVALID"</t>
                </list>
            </t>

            <t>
                Steps:
                <list style="numbers">
                    <t>D = ECVRF_decode_proof(pi_string)</t>
                    <t>If D is "INVALID", output "INVALID" and stop</t>
                    <t>(gamma, c, s) = D</t>
                    <t>u = g^s / y^c  (where / denotes EC point subtraction, i.e. the group operation applied to g^s and the inverse of y^c)</t>
                    <t>h = ECVRF_hash_to_curve(suite_string, y, alpha_string)</t>
                    <t>v = h^s / gamma^c  (where / again denotes EC point subtraction)</t>
                    <t>c' = ECVRF_hash_points(h, gamma, u, v)</t>
                    <t>
                        If c and c' are equal, output "VALID";
                        else output "INVALID" 
                    </t>
                </list>
            </t>
            
        </section>


        <section title="ECVRF Auxiliary Functions">

        <section title="ECVRF Hash To Curve" anchor="ecvrfH2C">
        
            <t>The ECVRF_hash_to_curve algorithm takes in the VRF input alpha
            and converts it to h, an EC point in G.
            This algorithm is the only place alpha is used in the proving and verfying. See
            <xref target="prehash" /> for further discussion.
            </t>

            <t>The algorithms in this section are not compatible with each other; the choice of algorithm is made in <xref target="suites"/>.</t>
            
            <section title="ECVRF_hash_to_curve_try_and_increment" anchor="ecvrfH2C1">
            
            <t>
            The following ECVRF_hash_to_curve_try_and_increment(suite_string, y, alpha) algorithm
            implements ECVRF_hash_to_curve in a simple and
            generic way that works for any elliptic curve. 
            </t>
            
            <t>
            The running time of this algorithm depends on alpha. 
            For the ciphersuites specified 
            in <xref target="suites"/>, this algorithm 
            is expected to find a valid curve point after approximately two attempts 
            (i.e., when ctr=1) on average. See also <xref target="Icart09"/>.
            </t>
            
            <t>
            However, because the running time of algorithm depends on alpha, 
            this algorithm SHOULD be avoided in 
            applications where it is important that
            the VRF input alpha remain secret. 
            </t>
            
            <t>
                ECVRF_hash_to_try_and_increment(suite_string, y, alpha_string)
            </t>
            <t>
                Input:
                <list>
                    <t>suite_string - a single octet specifying ECVRF ciphersuite. </t>
                    <t>y - public key, an EC point</t>
                    <t>alpha_string - value to be hashed, an octet string</t>
                </list>
            </t>
            <t>
                Output:
                <list>
                    <t>h - hashed value, a finite EC point in G</t>
                </list>
            </t>
            
            <t>
                Steps:
                <list style="numbers">
                    <t>ctr = 0</t>
                    <t>pk_string = point_to_string(y)</t>
                    <t>one_string = 0x01 = int_to_string(1, 1), a single octet with value 1 </t>
                    <t>h = "INVALID"</t>
                    <t>While h is "INVALID" or h is EC point at infinity:
                    <list style="letters">
                        <t>ctr_string = int_to_string(ctr, 4)</t>
                        <t>ctr = ctr + 1</t>
                        <t>hash_string = Hash(suite_string || one_string || pk_string || alpha_string || ctr_string)</t>
                        <t>attempted_hash_string = first 2n octects of hash_string</t> 
                        <t>h = rand_string_to_point(attempted_hash_string)</t>
                        <t>If h is not "INVALID" and cofactor > 1, set h = h^cofactor</t>
                    </list></t>
                    <t>Output h</t>
                </list>
            </t>
            
            
            </section>
            
            
            <section title="ECVRF_hash_to_curve_elligator2_25519" anchor="elligator2">
            
                <t> The following ECVRF_hash_to_curve_elligator2_25519(suite_string, y, alpha)
                algorithm implements ECVRF_hash_to_curve using the elligator2
                algorithm exclusively for Curve25519. 
                </t>
                                
                <t>
                    ECVRF_hash_to_curve_elligator2_25519(suite, y, alpha)
                </t>
                <t>
                    Input:
                    <list>
                        <t>suite_string - a single octet specifying ECVRF ciphersuite. </t>
                        <t>alpha - value to be hashed, an octet string</t>
                        <t>y - public key, an EC point</t>
                    </list>
                </t>
                <t>
                    Output:
                    <list>
                        <t>hc - hashed value, a finite EC point in G
                        </t>
                    </list>
                </t>
                
                <t> Fixed options:
                    <list>
                        <t> p = 2^255-19, the size of the finite field F, a prime, for Curve25519</t>
                        <t> A = 486662, Montgomery curve constant for Curve25519 </t>
                        <t> cofactor = 8 , the cofactor for Curve25519 </t>
                    </list>
                </t>
                
                <t> Constraints on options:
                    <list>
                        <t> output length of Hash is at least 16n (i.e., 256) bits</t>
                    </list>
                </t>
                
                <t>
                    Steps:
                    <list style="numbers">
                        <t>pk = point_to_string(y)</t>
                        <t>one = 0x01 = int_to_string(1, 1), a single octet with value 1 </t>
                        <t>hash = Hash(suite_string || one || pk || alpha )</t>
                        <t>truncatedHash = hash[0]...hash[31] (first 32 octets of hash)</t>
                        <t>OneTwentyEight = 0x80 = int_to_string(128, 1), a single octet with value 128</t>
                        <t>OneTwentySeven = 0x7F = int_to_string(127, 1), a single octet with value 127</t>
                        <t>x_0 = truncatedHash[31] &amp; OneTwentyEight, where &amp; denotes the bit-wise AND (let x_0 equal highest-order bit of octet 31 of truncated hash)</t>
                        <t>truncatedHash[31] = truncatedHash[31] &amp; OneTwentySeven (clear the high-order bit of octet 31 of truncatedHash)</t>
                        <t>r = little-endian-to-integer(truncatedHash) (convert truncatedHash to an integer, using little-endian encoding)</t>
                        <t>u = - A / (1 + 2*(r^2) )  mod p (the inverse of (1+2*(r^2)) modulo p is guaranteed to exist)</t>
                        <t>v_candidate = u * (u^2 + A*u + 1) mod p (evaluate the Montgomery equation for Curve25519)</t>
                        <t anchor="const1">Let e equal the Legendre symbol of v_candidate modulo p</t>
                        <t anchor="const2">If e is equal to 1 then final_u = u; else final_u = (-A - u) mod p (final_u is the Montgomery u-coordinate of the output)</t>
                        <t>y = (final_u - 1) / (final_u + 1) mod p (y is the Edwards coordinate corresponding to final_u)</t>
                        <t>Form an octet string encoding of an elliptic curve point out of y and x_0 per the encoding defined in Section 5.1.2 of
                            <xref target="RFC8032" />, as follows:
                            <list style="letters">
                                <t>hEncoded = little-endian-integer-to-octet-string (y)</t>
                                <t>hEncoded[31] = hEncoded[31] | x_0, where | denotes the bit-wise OR</t>
                            </list>
                        </t>
                        <t>h = string_to_point(hEncoded)</t>
                        <t>hc = h^cofactor</t>
                        <t>Output hc</t>
                    </list>
                </t>
                
                
                <t> In order to make this algorithm run in time that is (almost) independent
                    of the input (so-called "constant-time"), implementers should pay particular attention
                    to Steps 13 and 14 above.
                    These steps can be implemented using the following approach:
                <list>
                    <t> e = (v_candidate) ^ ((p-1)/2) mod p</t>
                    <t>final_u = (e*u + (e-1) * (A/2)) mod p</t>
                </list>
                The first step will produce a value e that is either 1 or p-1. Implementers should also ensure that the second step
                runs in the same amount of time regardless of e by ensuring that
                the multiplication operation * runs in constant time.
                </t>
                
                <t>
                Alternatively, let CMOV(result_if_1, result_if_0, selector) be the function that returns result_if_1 when
                selector is 1 and  result_if_0 when selector is 0. If CMOV is implemented in constant time, then steps 13 and 14 above can be implemented as follows:
                <list>
                    <t>e = (v_candidate ^ ((p-1)/2))+1 mod p (at this point e is either 0 or 2)</t>
                    <t>b = e/2 (note that only the least significant byte of e is needed for this operation)</t>
                    <t>negative_u = (-A-u) mod p</t>
                    <t>final_u = CMOV(u, negative_u, b)</t>
                </list>
                [TODO: Should we explain how to implement CMOV in constant time?]
                [TODO: Do we have appropriate references to the literature where Elligator2 was proposed and to other standards?]
                </t>

                <t>
                    If having this algorithm run in constant time is not important, then there are much faster algorithms
                    to compute the Legendre symbol (which is the same as the Jacobi symbol because p is a prime).
                    See, for example, Section 12.3 of <xref target="ntb"/>.
                </t>
                
            </section>
            
            <section title="ECVRF_hash_to_curve_Simplified_SWU" anchor="SimpleSWU">
                
                <t> The following ECVRF_hash_to_curve_Simplified_SWU(suite, y, alpha)
                    algorithm implements ECVRF_hash_to_curve using the simplified Shallue-Woestijne-Ulas
                    algorithm from [TODO: add reference to <xref target="BCIMRT10"/> and <xref target="SW18"/>, latest version] for any curve with prime p that is congruent
                    to 3 modulo 4.
                </t>
                
                <t>
                    ECVRF_hash_to_curve_Simplified_SWU(suite, y, alpha)
                </t>
                <t>
                    Input:
                    <list>
                        <t>suite - a single octet specifying ECVRF ciphersuite. </t>
                        <t>alpha - value to be hashed, an octet string</t>
                        <t>y - public key, an EC point</t>
                    </list>
                </t>
                <t>
                    Output:
                    <list>
                        <t>h - hashed value, a finite EC point in G
                        </t>
                    </list>
                </t>
                
                <t> Fixed options:
                    <list>
                        <t> a and b, constants for the Weierstrass form elliptic curve equation y^2 = x^3 + ax +b for the curve E</t>
                    </list>
                </t>
                <t>
                    Steps:
                    <list style="numbers">
                        <t>pk = EC2OSP(y)</t>
                        <t>one = 0x01 = I2OSP(1, 1), a single octet with value 1 </t>
                        <t>hash = Hash(suite || one || pk || alpha )</t>
                        <t>t = big-endian-to-integer(hash) (convert hash to an integer, using big-endian encoding)</t>
                        <t>negative_t_squared = -t^2 mod p</t>
                        <t>denominator = negative_t_squared^2 + negative_t_squared mod p (denominator is t^4-t^2 mod p)</t>
                        <t>if denominator = 0, x = 0 [TODO: this won't always work]. Else x = (-b/a) * (1 + (1/denominator)) mod p.</t>
                        <t>y_candidate = x^3 + a*x + b mod p</t>
                        <t>Let e equal the Legendre symbol of y_candidate modulo p</t>
                        <t>If e is equal to 1 then final_x = x; else final_x = negative_t_square * x mod p (final_x is the x-coordinate of the output)</t>
                        <t>h = OS2ECP(toString(final_x)</t>
                        <t>hc = h^cofactor</t>
                        <t>Output hc</t>
                    </list>
                </t>
                
                
                <t> In order to make this algorithm run in time that is (almost) independent
                    of the input (so-called "constant-time"), implementers should pay particular attention
                    to Steps 13 and 14 above.
                    These steps can be implemented using the following approach:
                    <list>
                        <t> e = v ^ ((p-1)/2) mod p</t>
                        <t>final_u = (e*u + (e-1) * (A/2)) mod p</t>
                    </list>
                    The first step will produce a value e that is either 1 or p-1. Implementers should also ensure that the second step
                    runs in the same amount of time regardless of e by ensuring that
                    the multiplication operation * runs in constant time.
                </t>
                
                <t>
                    Alternatively, let CMOV(result_if_1, result_if_0, selector) be the function that returns result_if_1 when
                    selector is 1 and  result_if_0 when selector is 0. If CMOV is implemented in constant time, then steps 13 and 14 above can be implemented as follows:
                    <list>
                        <t>e = (v ^ ((p-1)/2))+1 mod p (at this point e is either 0 or 2)</t>
                        <t>b = e/2 (note that only the least significant byte of e is needed for this operation)</t>
                        <t>negative_u = (-A-u) mod p</t>
                        <t>final_u = CMOV(u, negative_u, b)</t>
                    </list>
                    [TODO: Should we explain how to implement CMOV in constant time?]
                </t>
                
                <t>
                    If having this algorithm run in constant time is not important, then there are much faster algorithms
                    to compute the Legendre symbol (which is the same as the Jacobi symbol because p is a prime).
                    See, for example, Section 12.3 of <xref target="ntb"/>.
                </t>
                
            </section>
            
        </section>

        <section title="ECVRF Hash Points" anchor="ecvrfHashPoints">
                     
            <t>
                ECVRF_hash_points(p1, p2, ..., pm)
            </t>
            <t>
                Input:
                <list>
                    <t>pj - EC point in G</t>
                </list>
            </t>
            <t>
                Output:
                <list>
                    <t>c - hash value, integer between 0 and 2^(8n)-1</t>
                </list>
            </t>
            <t>
                Steps:
                <list style="numbers">
                    <t>two_string = 0x02 = int_to_string(2, 1), a single octet with value 2 </t>
                    <t>Initialize str = suite_string || two_string </t>
                    <t>for pj in [p1, p2, ... pm]:
                       <vspace/>str = str || point_to_string(pj)
                    </t>
                    <t>c_string = Hash(str)</t>
                    <t>truncated_c_string = first n octets of c_string</t>
                    <t>c = string_to_int(truncated_c_string)</t>
                    <t>Output c</t>
                </list>
            </t>
            
            
                   
        </section>

        <section title="ECVRF Decode Proof">
            <t>
                ECVRF_decode_proof(pi_string)
            </t>
            <t>
                Input:
                <list>
                    <t>pi_string - VRF proof, octet string (m+3n octets)</t>
                </list>
            </t>
            <t>
                Output:
                <list>
                    <t>"INVALID", or </t>
                    <t>gamma - EC point</t>
                    <t>
                    c - integer between 0 and 2^(8n)-1
                    </t>
                    <t>
                    s - integer between 0 and 2^(16n)-1
                    </t>
                </list>
            </t>
            <t>
                Steps:
                <list style="numbers">
                    <t>let gamma_string, c_string, s_string be 
                    pi_string split after m-th and m+n-th octet</t>
                    <t>gamma = string_to_point(gamma_string)</t>
                    <t>if gamma = "INVALID" output "INVALID" and stop.</t>
                    <t>c = string_to_int(c_string)</t>
                    <t>s = string_to_int(s_string)</t>
                    <t>Output gamma, c, and s</t>
                </list>
            </t>
        </section>

        </section><!-- Auxiliary Functions -->

        <section title="ECVRF Ciphersuites" anchor="suites">
                
        <t>This document defines ECVRF-P256-SHA256 as follows:
        <list style="symbols">
        <t>
        suite_string = 0x01 = int_to_string(1, 1). </t>
        <t>
            The EC group G is the NIST-P256 elliptic curve, with curve parameters
            as specified in <xref target="FIPS-186-3"></xref> (Section D.1.2.3) 
            and <xref target="RFC5114"></xref>  (Section 2.6). For this group,
            2n = 32 and cofactor = 1.
        </t>
        <t> The key pair generation primitive is specified in
            Section 3.2.1 of <xref target="SECG1" /> (q, g, SK, and PK in this document
            correspond to in n, G, d, and Q in Section 3.2.1 of <xref target="SECG1" />).
            In this ciphersuite, the secret scalar x is equal to the private key SK.
        </t>
        <t> The ECVRF_nonce_generation function is as specified in 
        <xref target="RFC6979" /> Section 3.2 Steps b-h 
        (omitting Step a and using h_string that is provided as input to 
        ECVRF_nonce_generation), with the hash function
        SHA-256 as specified in <xref target="RFC6234" /></t>
        
        <t>The int_to_string function is the I2OSP function specified in Section 
        4.1 of <xref target="RFC8017" />. (This is big endian representation.)</t>

        <t>The string_to_int function is the OS2IP function specified in Section 
        4.2 of <xref target="RFC8017" />. (This is big endian representation.)</t>

        <t>
            The point_to_string function is specified in Section 2.3.3 of 
            <xref target="SECG1" /> with point compression on.
            This implies m = 2n + 1 = 33.
        </t>
        
        <t> The string_to_point function is specified in Section 2.3.4
         of <xref target="SECG1" />.
        </t>
        
        <t> rand_string_to_point(h_string) = string_to_point(0x02 || h_string) 
        (where 0x02 is a single 
        octet with value 2, 0x02=int_to_string(2, 1)). The input h is a 32-octet string
        and the output is either an EC point or "INVALID". </t>
        
        <t>
            The hash function Hash is SHA-256 as specified in <xref target="RFC6234"/>.
        </t>
        <t>
            The ECVRF_hash_to_curve function is as specified in <xref target="ecvrfH2C1"/>.
        </t>
        </list>
        </t>
        
        <t>This document defines ECVRF-ED25519-SHA512 as follows:
        <list style="symbols">
        <t>
        suite_string = 0x02 = int_to_string(2, 1). </t>
        <t>
            The EC group G is the Ed25519
            elliptic curve with parameters defined in Table 1 of
             <xref target="RFC8032" />.       
            For this group, 2n = 32 and cofactor = 8.
        </t>
        <t> The private key and generation of the secret scalar and the public 
        key are specified in Section 5.1.5 of <xref target="RFC8032" /></t>
        
        <t> The ECVRF_nonce_generation function as follows.  Perform 
        <xref target="RFC8032" /> Section 5.1.6 Steps 1-2, 
        with dom2(F, C) equal to the empty string and PH(M) equal to h_string. 
        Reduce the output modulo q.</t>
        
        <t>The int_to_string function as specified in the first paragraph of
        Section 5.1.2 of <xref target="RFC8032" />. (This is little endian representation.)</t>

        <t>The string_to_int function interprets the string as an integer in little-endian
       representation.</t>
                
        <t> The point_to_string function is specified in Section 5.1.2 of <xref target="RFC8032" />. 
        This implies m = 2n = 32.</t>
        
        <t> The string_to_point function is specified in Section 5.1.3 of <xref target="RFC8032" />.
        </t>

        <t>rand_string_to_point function is equivalent to the string_to_point function.</t>

        <t>
            The hash function Hash is SHA-512 as specified in <xref target="RFC6234"/>.
        </t>
        <t>
            The ECVRF_hash_to_curve function is as specified in <xref target="ecvrfH2C1"/>.
        </t>
        </list>
        </t>
   
   <t>This document defines ECVRF-ED25519-SHA512-Elligator2 as follows:
    
        <list style="symbols">
        <t> This ciphersuite is identical to ECVRF-ED25519-SHA512 except that
        the ECVRF_hash_to_curve function is as specified in <xref target="elligator2"/> and 
        suite_string = 0x03 = int_to_string(3, 1).
        </t>
        </list>
        </t>
    
        
        </section>
        

        <section title="When the ECVRF Keys are Untrusted" anchor="keycheck">
        
        <t>The ECVRF as specified above is a VRF that satisfies the
        "trusted uniqueness", "trusted collision resistance", and 
        "full pseudorandomness" properties defined in <xref target="secdef"/>.
        In order to obtain "full uniqueness" and "full collision resistance" (which provide
        protection against a malicious VRF public key), the Verifier MUST
        perform
        the following additional validation procedure upon receipt of the public
        VRF key. The public VRF key MUST NOT be used if this procedure returns "INVALID".
        </t>
        
        <t>
        Note that this procedure is not sufficient if the elliptic curve E
        or the point g, the generator of group G, is untrusted. If the prover is untrusted,
        the Verifier MUST
        obtain E and g from a trusted source, such as a ciphersuite specification, rather
        than from the prover.
        </t>
        
        <t> This procedure supposes that the public key provided to the Verifier is an octet 
        string. The procedure returns "INVALID" if the public key in invalid. 
        Otherwise, it returns y, the public key as an EC point.
        </t>
        
        
        <section title="ECVRF Validate Key">
      
            <t>
                ECVRF_validate_key(PK)
            </t>
            <t>
                Input:
                <list>
                    <t>PK - public key, an octet string</t>
                </list>
            </t>
            <t>
                Output:
                <list>
                    <t>"INVALID", or </t>
                    <t>y - public key, an EC point</t>
                </list>
            </t>
            <t>
                Steps:
                <list style="numbers">
                    <t>y = string_to_point(PK)</t>
                    <t>If y is "INVALID", output "INVALID" and stop</t>
                    <t>If y^cofactor is the EC point at infinty, output "INVALID" and stop</t>
                    <t>Output y</t>
                </list>
            </t>
        
        </section>       
        </section><!-- Untrusted keys -->

    </section>
    
    
    <section title="Implementation Status" anchor="imp">
    
        <t>
            An implementation of the RSA-FDH-VRF (SHA-256) and ECVRF-P256-SHA256 was
            first developed
            as a part of the NSEC5 project <xref target="I-D.vcelak-nsec5" /> and is available
            at <eref target="http://github.com/fcelda/nsec5-crypto" />. 
            The ECVRF implementation may be out of date as this spec has evolved.
        </t>
    
    <t>
    The Key Transparency project at Google
    uses a VRF implemention that is similar to
    the ECVRF-P256-SHA256, with a few minor changes
    including the use of SHA-512 instead of SHA-256. Its implementation
    is available <eref target="https://github.com/google/keytransparency/blob/master/core/vrf/vrf.go" />
    </t>
    
    
    <t>
    An implementation by Yahoo! similar to the ECVRF is available at
    <eref target="https://github.com/r2ishiguro/vrf"/>.
    </t>
    
    
    <t>
    An implementation similar to ECVRF is available as part of the
    CONIKS implementation in Golang at 
    <eref target="https://github.com/coniks-sys/coniks-go/tree/master/crypto/vrf"/>.
    </t>
    
    
    <t>
    Open Whisper Systems also uses a VRF very similar to 
    ECVRF-ED25519-SHA512-Elligator, called VXEdDSA, and specified here:
    <eref target="https://whispersystems.org/docs/specifications/xeddsa/" />
    </t> 
    </section>    


    <section title="Security Considerations" anchor="securitycons">


    <section title="Key Generation">

    <t>Applications that use the VRFs defined in this
    document MUST ensure that that the VRF key is generated correctly,
    using good randomness.
    </t>
    
    <section title="Uniqueness and collision resistance with untrusted keys">
        
    <t>The ECVRF as specified in <xref target="ecvrfprove"/>-<xref target="suites"/>
    statisfies the "trusted uniqueness" and "trusted collision resistance" properties
    as long as the VRF keys are generated correctly, with good randomness.
    If the Verifier trusts the VRF keys are generated correctly, it MAY use 
    the public key y as is.
    </t>
    
    <t>
    However, if the ECVRF uses keys that could be generated adversarially, then the
    the Verfier MUST first perform the validation procedure ECVRF_validate_key(PK)
    (specified in <xref target="keycheck"/>)  upon receipt of the
    public key PK as an octet string.  If the validation procedure
    outputs "INVALID", then the public key MUST not be used.  
    Otherwise, the procedure will output a valid public key y, 
    and the ECVRF with public key y satisfies the "full uniqueness" and
    "full collision resistance" properties.
    </t>
    
    
    <t>The RSA-FDH-VRF statisfies the "trusted uniqueness" and "trusted collision resistance" properties
    as long as the VRF keys are generated correctly, with good randomness.
    These properties may not hold if the keys are generated adversarially  
    (e.g., if RSA is not permutation). Meanwhile, 
    the "full uniqueness" and "full collision resistance" are 
    properties that hold  even if VRF keys are generated by an adversary.
    The RSA-FDH-VRF defined in this document does not have these properties.
    However, if adversarial key generation is a concern, the
    RSA-FDH-VRF may be modifed to have these 
    properties by adding additional cryptographic checks
    that its public key has the right form.  These modifications are left for future specification.
    </t>
    
    </section>
    
    <section title="Pseudorandomness with untrusted keys">
    
    <t> Without good randomness, the "pseudorandomness"
    properties of the VRF may not hold. Note that it is not possible to guarantee 
    pseudorandomness in the face of adversarially generated VRF keys.  This is
    because an adversary can always use bad randomness to generate the VRF keys, 
    and thus, the VRF output may not be pseudorandom.
    </t>
    </section>
    </section>


    
    <section title="Selective vs Full Pseudorandomness">
    
    <t><xref target="nsec5ecc"/> presents cryptographic reductions to an 
    underlying hard problem (e.g. Decisional Diffie Hellman for the ECVRF, or the
    standard RSA assumption for RSA-FDH-VRF) that prove the VRFs specificied in this 
    document possess full pseudorandomness
    as well as selective pseudorandomness. 
    However, the cryptographic reductions are tighter for selective
    pseudorandomness than for full pseudorandomness.  This means the 
    the VRFs have quantitavely stronger security 
    guarentees for selective pseudorandomness. 
    </t>
    
    <t> Applications that are concerned about tightness of cryptographic
    reductions therefore have two options.
    
    <list style="symbols">
    <t> They may choose to ensure that selective pseudorandomness is sufficient for
    the application. That is, that
	pseudorandomness of outputs matters only for inputs that are chosen
    independently of the VRF key. 
    </t>
    <t>If full pseudorandomness is required for the application, the application
    may increase
    security parameters to make up for the loose security reduction. 
    For RSA-FDH-VRF, this means increasing the RSA key length. For 
    ECVRF, this means increasing the cryptographic strength of the EC group
    G. For both RSA-FDH-VRF and ECVRF the cryptographic strength of the
    hash function Hash may also potentially need to be increased.
    </t>
    </list>
    </t>
    </section>


 <section title="Proper pseudorandom nonce for ECVRF">

    <t>
    The security of the ECVRF defined in this document relies on the 
    fact that nonce k used in the ECVRF_prove algorithm is
    chosen uniformly and pseudorandomly modulo q, and is unknown to the advesrary.
    Otherwise, an adversary may be able to recover
    the private VRF key x (and thus break pseudorandomness of the VRF)
    after observing several valid VRF proofs pi. The nonce generation methods
    specified in the ECVRF ciphersuites of <xref target="suites"/>
    are designed with this requirement in mind.
    </t>
    
    </section>
 
  <section title="Side-channel attacks">
    
    <t>Side channel attacks on cryptographic primatives are an important issue.
    Here we discuss only one such side channel:  timing attacks that can 
    be used to leak information about the VRF input alpha.  Implementers should
    take care to avoid side-channel attacks that leak information about 
    the VRF private key SK (and the nonce k used in the ECVRF).</t>
        
    <t>The ECVRF_hash_to_curve_try_and_increment algorithm defined in
    <xref target="ecvrfH2C1" /> SHOULD NOT be used in applications where
    the VRF input alpha is secret and is hashed by the VRF on-the-fly.
    This is because the algorithm's running time depends
    on the VRF input alpha, and thus creates a timing channel that
    can be used to learn information about alpha. 
    That said, for most inputs the amount of information obtained from
    such a timing attack is likely to be small (1 bit, on average), since the algorithm 
    is expected to find a valid curve point after only two attempts.  
    However, there might be inputs which cause the algorithm to make many attempts
    before it finds a valid curve point; for such inputs, the information leaked
    in a timing attack will be more than 1 bit. 
    </t>

    
    <t>Meanwhile, ECVRF-ED25519-SHA512-Elligator2 runs in time constant in alpha 
    if the implementation of the ECVRF_hash_to_curve function
    specified in <xref target="elligator2"/> also runs in constant time.
    </t>
    
    
  </section>

<section title="Proofs Provide No Secrecy for VRF Input">
    <t>The VRF proof pi is not designed to provide secrecy and, in general, 
        may reveal the VRF input alpha.
        Anyone who knows PK and pi is able to perform an offline
        dictionary attack to search for alpha, by verifying guesses for alpha using VRF_verify.
        This is in contrast to the VRF hash output beta which, without the proof, is pseudorandom
        and thus is designed to reveal no information about alpha.
    </t>
</section>

<section title="Prehashing" anchor="prehash" >
    <t>The VRFs specified in this document allow for read-once access to
        the input alpha for both signing and verifying. Thus, additional 
        prehashing of alpha (as specified, for example, in
        <xref target="RFC8032" /> for EdDSA signatures) is not needed, 
        even for applications that need to handle long alpha or
        to support the
        Initialized-Update-Finalize (IUF) interface (in such an interface,
        alpha is not supplied
        all at once, but rather in pieces by a sequence of calls to Update).
        The ECVRF, in particular, uses alpha only in
        ECVRF_hash_to_curve. The curve point h becomes the representative 
        of alpha thereafter. Note that the suite_string octet and the public key
        are hashed together with alpha in ECVRF_hash_to_curve, which ensures
        that the curve (including the generator g) and the public
    key are included indirectly into subsequent hashes.</t>
</section>
 
 
 <section title="Hash function domain separation and future-proofing">
     
     <t>
         Hashing is used for four different purposes in ECVRF (namely, in hash_to_curve, nonce_generation, hash_points, and proof2hash). The
         theoretical analysis assumes each of these four functions is a separate random oracle. 
         This analysis still holds even if the same hash function is used, as long as the four 
         queries made to the hash function for a given SK and alpha are overwhelmingly unlikely 
         to equal each other or to any queries made to the hash function for the same SK and 
         different alpha. This is indeed the case for the ECVRF ciphersuites defined in this document, because:
         <list style="symbols">
          <t>inputs to the hash function used during nonce_generation are unlikely to equal 
          to inputs given to hash_to_curve, proof2hash, and hash_points. This
          follows since nonce_generation inputs a secret to the hash function that is not used by 
          honest parties as input to any other hash function, and is not available to the adversary</t>
          <t>the second octet of the input to the hash function used in 
          hash_to_curve, proof2hash, and 
          hash_points are all different</t>
         </list>
     </t>
     
     <t>If future designs need to specify variants (e.g., additional ciphersuites) of the design in this document,
         then, to avoid the possibility
         that an adversary can obtain a VRF output under one variant, and then claim it was obtained under
         another variant,
        they should specify a different suite_string constant. This way, the inputs
        to the hash_to_curve hash function used in producing h are 
        guaranteed to be different; since all the other hashing done by the prover
        depends on h, inputs all the hash functions used by the prover will also be
        different as long as hash_to_curve is collision resistant.
    </t>
     
 </section>


   

    </section>


    <section title="Change Log">
        <t>
            Note to RFC Editor: if this document does not obsolete an existing RFC,
            please remove this appendix before publication as an RFC.
        </t>

        <t>
            <list>
                <!--<t>
                    draft-goldbe-vrf-00 - Forked this document from draft-vcelak-nsec5-04. 
                    Cleaned up the definitions of VRF algorithms.
                    Added security definitions for VRF and security considerations.
                    Parameterized ECVRF so it could support curves other than
                    P-256 and Ed25519.
                </t>
                <t>
                    draft-goldbe-vrf-01 - Fixed ECVRF to work when cofactor > 1.  
                    Changed ECVRF_proof2hash(pi) so that it outputs a value raised
                    to the cofactor and then processed by the cryptographic hash function Hash. 
                    Included the VRF public key y as input to the hash function
                    ECVRF_hash_to_curve1.
                    Cleaned up ciphersuites and ECVRF description so that it works with
                    EC point encodings for both P256 and Ed25519 curves.
                    Added ECVRF_validate_key so that ECVRF can satisfy "full
                    uniqueness" and "full collision" resistance.
                    Updated implementation status.
                    Added "an additional pseudorandomness property" to security
                    definitions.
                </t>-->
                <t> 00 - Forked this document from draft-goldbe-vrf-01.</t>
                <t> 01 - Minor updates, mostly highlighting TODO items.</t>
                <t> 02 - Added specification of elligator2 for Curve25519, along
                with ciphersuites for ECVRF-ED25519-SHA512-Elligator.
                Changed 
                ECVRF-ED25519-SHA256 suite_string to ECVRF-ED25519-SHA512. (This change
                made because Ed25519 in <xref target="RFC8032"/> signatures 
                use SHA512 and not SHA256.) 
                Made ECVRF nonce generation a separate component, so that nonces are determinsitic.
                In ECVRF proving, changed + to - (and made corresponding
                verification changes) in order to be consistent with EdDSA and ECDSA.
                Highlighted that ECVRF_hash_to_curve acts like a prehash.
                Added "suites" variable to ECVRF for future-proofing.
                Ensured domain separation for hash functions by modifying hash_points and added
                discussion about domain separation.
                Updated todos in the "additional pseudorandomness property" 
                section. Added an discussion of secrecy into security considerations.
                Removed g and PK=y from ECVRF_hash_points because they are already present
                via h, which is computed via hash_to_curve using the suite_string (which identifies g) and y.</t>
            </list>
        </t>
    </section>

    <section title="Contributors">
   
            
        <t>
            This document also would not be possible without the work of
            Moni Naor (Weizmann Institute),
            Sachin Vasant (Cisco Systems), and
            Asaf Ziv (Facebook).
            Shumon Huque (Salesforce), David C. Lawerence (Akamai), and Trevor Perrin provided
            valuable input to this draft.
        </t>
    </section>

</middle>

<back>
    <!-- References Section -->

<!--
     Section 4.7f of [RFC2223bis] specifies the requirements for the
     references sections.  In particular, there MUST be separate lists of
     normative and informative references, each in a separate section.
     The style SHOULD follow that of recently published RFCs.

     In general, each normative reference SHOULD reference the most recent
     version of the specification in question.
-->

    <references title="Normative References">
        <?rfc include="reference.RFC.2119.xml"?>
        <?rfc include="reference.RFC.8017.xml"?>
        <?rfc include="reference.RFC.5114.xml"?>
        <?rfc include="reference.RFC.6234.xml"?>
        <?rfc include="reference.RFC.8032.xml"?>
        <?rfc include="reference.RFC.6979.xml"?>

        <reference anchor="FIPS-186-3">
            <front>
                <title>Digital Signature Standard (DSS)</title>
                <author><organization>National Institute for Standards and Technology</organization></author>
                <date year="2009" month="June" />
            </front>
            <seriesInfo name="FIPS" value="PUB 186-3" />
        </reference>

        <reference anchor="SECG1" target="http://www.secg.org/sec1-v2.pdf">
            <front>
                <title>SEC 1: Elliptic Curve Cryptography</title>
                <author><organization>Standards for Efficient Cryptography Group (SECG)</organization></author>
                <date year="2009" month="May" />
            </front>
            <seriesInfo name="Version" value="2.0" />
        </reference>

    </references>

    <references title="Informative References">

        <reference anchor="ntb" target="http://www.shoup.net/ntb/ntb-v2.pdf">
            <front>
                <title>A Computational Introduction to Number Theory and Algebra</title>
                <author initials="V." surname="Shoup"><organization /></author>
                <date year="2008" />
            </front>
        </reference>

        <reference anchor="nsec5ecc" target="https://eprint.iacr.org/2017/099.pdf">
            <front>
                <title>Making NSEC5 Practical for DNSSEC</title>
                <author initials="D." surname="Papadopoulos"><organization /></author>
                <author initials="D." surname="Wessels"><organization /></author>
                <author initials="S." surname="Huque"><organization /></author>
                <author initials="J." surname="Vcelak"><organization /></author>
                <author initials="M." surname="Naor"><organization /></author>
                <author initials="L." surname="Reyzin"><organization /></author>
                <author initials="S." surname="Goldberg"><organization /></author>
                <date year="2017" month="February" />
            </front>
            <seriesInfo name="in" value="ePrint Cryptology Archive 2017/099" />
        </reference>

        <reference anchor="MRV99">
            <front>
                <title>Verifiable Random Functions</title>
                <author initials="S." surname="Michali"><organization /></author>
                <author initials="M." surname="Rabin"><organization /></author>
                <author initials="S." surname="Vadhan"><organization /></author>
                <date year="1999" />
            </front>
            <seriesInfo name="in" value="FOCS" />
        </reference>

        <reference anchor="Icart09">
            <front>
                <title>How to Hash into Elliptic Curves</title>
                <author initials= "T." surname="Icart"><organization /></author>
                <date year="2009" />
            </front>
            <seriesInfo name="in" value="CRYPTO" />
        </reference>

        <reference anchor="BCIMRT10">
            <front>
                <title>Efficient Indifferentiable Hashing into Ordinary Elliptic Curves</title>
                <author initials= "E." surname="Brier"><organization /></author>
                <author initials= "J.-S." surname="Coron"><organization /></author>
                <author initials= "T." surname="Icart"><organization /></author>
                <author initials= "D." surname="Madore"><organization /></author>
                <author initials= "H." surname="Randriam"><organization /></author>
                <author initials= "M." surname="Tibouchi"><organization /></author>
                <date year="2010" />
            </front>
            <seriesInfo name="in" value="CRYPTO" />
        </reference>

        <reference anchor="SW18">
            <front>
                <title>Hashing to Elliptic Curves</title>
                <author initials= "E." surname="Sullivan"><organization /></author>
                <author initials= "C." surname="Wood"><organization /></author>
                <date year="2018" />
            </front>
        </reference>


        <?rfc include="reference.I-D.vcelak-nsec5.xml"?>


    </references>

    <!--
    <section title="Open Issues">
        <t>
            Note to RFC Editor: please remove this appendix before publication as an RFC.
        </t>

        <t>
            <list style="numbers">
                <t>Open issue.</t>
            </list>
        </t>
    </section>
    -->
  </back>
</rfc>
<!-- vim: et ts=4 sts=4 sw=4 colorcolumn=100 spell :
-->
