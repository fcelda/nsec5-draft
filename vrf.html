<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Verifiable Random Functions (VRFs)</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Rationale">
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 Requirements">
<link href="#rfc.section.1.3" rel="Chapter" title="1.3 Terminology">
<link href="#rfc.section.2" rel="Chapter" title="2 VRF Algorithms">
<link href="#rfc.section.3" rel="Chapter" title="3 VRF Security Properties">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Full Uniqueness or Trusted Uniqueness">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Full Collison Resistance or Trusted Collision Resistance">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Full Pseudorandomness or Selective Pseudorandomness">
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 An additional pseudorandomness property">
<link href="#rfc.section.4" rel="Chapter" title="4 RSA Full Domain Hash VRF (RSA-FDH-VRF)">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 RSA-FDH-VRF Proving">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 RSA-FDH-VRF Proof To Hash">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 RSA-FDH-VRF Verifying">
<link href="#rfc.section.5" rel="Chapter" title="5 Elliptic Curve VRF (EC-VRF)">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 EC-VRF Proving">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 EC-VRF Proof To Hash">
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 EC-VRF Verifying">
<link href="#rfc.section.5.4" rel="Chapter" title="5.4 EC-VRF Auxiliary Functions">
<link href="#rfc.section.5.4.1" rel="Chapter" title="5.4.1 EC-VRF Hash To Curve">
<link href="#rfc.section.5.4.2" rel="Chapter" title="5.4.2 EC-VRF Nonce Generation">
<link href="#rfc.section.5.4.3" rel="Chapter" title="5.4.3 EC-VRF Hash Points">
<link href="#rfc.section.5.4.4" rel="Chapter" title="5.4.4 EC-VRF Decode Proof">
<link href="#rfc.section.5.5" rel="Chapter" title="5.5 EC-VRF Ciphersuites">
<link href="#rfc.section.5.6" rel="Chapter" title="5.6 When the EC-VRF Keys are Untrusted">
<link href="#rfc.section.5.6.1" rel="Chapter" title="5.6.1 EC-VRF Validate Key">
<link href="#rfc.section.6" rel="Chapter" title="6 Implementation Status">
<link href="#rfc.section.7" rel="Chapter" title="7 Security Considerations">
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Key Generation">
<link href="#rfc.section.7.1.1" rel="Chapter" title="7.1.1 Uniqueness and collision resistance with untrusted keys">
<link href="#rfc.section.7.1.2" rel="Chapter" title="7.1.2 Pseudorandomness with untrusted keys">
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Selective vs Full Pseudorandomness">
<link href="#rfc.section.7.3" rel="Chapter" title="7.3 Proper randomness for EC-VRF">
<link href="#rfc.section.7.4" rel="Chapter" title="7.4 Timing attacks">
<link href="#rfc.section.8" rel="Chapter" title="8 Change Log">
<link href="#rfc.section.9" rel="Chapter" title="9 Contributors">
<link href="#rfc.references" rel="Chapter" title="10 References">
<link href="#rfc.references.1" rel="Chapter" title="10.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="10.2 Informative References">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.9.8 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Goldberg, S., Reyzin, L., Papadopoulos, D., and J. Vcelak" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-irtf-cfrg-vrf-02" />
  <meta name="dct.issued" scheme="ISO8601" content="2018-20" />
  <meta name="dct.abstract" content="A Verifiable Random Function (VRF) is the public-key version of a keyed cryptographic hash. Only the holder of the private key can compute the hash, but anyone with public key can verify the correctness of the hash.  VRFs are useful for preventing enumeration of hash-based data structures.  This document specifies several VRF constructions that are secure in the cryptographic random oracle model. One  VRF uses RSA and the other VRF uses Eliptic Curves (EC).  " />
  <meta name="description" content="A Verifiable Random Function (VRF) is the public-key version of a keyed cryptographic hash. Only the holder of the private key can compute the hash, but anyone with public key can verify the correctness of the hash.  VRFs are useful for preventing enumeration of hash-based data structures.  This document specifies several VRF constructions that are secure in the cryptographic random oracle model. One  VRF uses RSA and the other VRF uses Eliptic Curves (EC).  " />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">CFRG</td>
<td class="right">S. Goldberg</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">L. Reyzin</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">Boston University</td>
</tr>
<tr>
<td class="left">Expires: December 22, 2018</td>
<td class="right">D. Papadopoulos</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Hong Kong University of Science and Techology</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">J. Vcelak</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">NS1</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">June 20, 2018</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Verifiable Random Functions (VRFs)<br />
  <span class="filename">draft-irtf-cfrg-vrf-02</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>A Verifiable Random Function (VRF) is the public-key version of a keyed cryptographic hash. Only the holder of the private key can compute the hash, but anyone with public key can verify the correctness of the hash.  VRFs are useful for preventing enumeration of hash-based data structures.  This document specifies several VRF constructions that are secure in the cryptographic random oracle model. One  VRF uses RSA and the other VRF uses Eliptic Curves (EC).  </p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on December 22, 2018.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2018 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Rationale</a>
</li>
<li>1.2.   <a href="#rfc.section.1.2">Requirements</a>
</li>
<li>1.3.   <a href="#rfc.section.1.3">Terminology</a>
</li>
</ul><li>2.   <a href="#rfc.section.2">VRF Algorithms</a>
</li>
<li>3.   <a href="#rfc.section.3">VRF Security Properties</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Full Uniqueness or Trusted Uniqueness</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">Full Collison Resistance or Trusted Collision Resistance</a>
</li>
<li>3.3.   <a href="#rfc.section.3.3">Full Pseudorandomness or Selective Pseudorandomness</a>
</li>
<li>3.4.   <a href="#rfc.section.3.4">An additional pseudorandomness property</a>
</li>
</ul><li>4.   <a href="#rfc.section.4">RSA Full Domain Hash VRF (RSA-FDH-VRF)</a>
</li>
<ul><li>4.1.   <a href="#rfc.section.4.1">RSA-FDH-VRF Proving</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">RSA-FDH-VRF Proof To Hash</a>
</li>
<li>4.3.   <a href="#rfc.section.4.3">RSA-FDH-VRF Verifying</a>
</li>
</ul><li>5.   <a href="#rfc.section.5">Elliptic Curve VRF (EC-VRF)</a>
</li>
<ul><li>5.1.   <a href="#rfc.section.5.1">EC-VRF Proving</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">EC-VRF Proof To Hash</a>
</li>
<li>5.3.   <a href="#rfc.section.5.3">EC-VRF Verifying</a>
</li>
<li>5.4.   <a href="#rfc.section.5.4">EC-VRF Auxiliary Functions</a>
</li>
<ul><li>5.4.1.   <a href="#rfc.section.5.4.1">EC-VRF Hash To Curve</a>
</li>
<li>5.4.2.   <a href="#rfc.section.5.4.2">EC-VRF Nonce Generation</a>
</li>
<li>5.4.3.   <a href="#rfc.section.5.4.3">EC-VRF Hash Points</a>
</li>
<li>5.4.4.   <a href="#rfc.section.5.4.4">EC-VRF Decode Proof</a>
</li>
</ul><li>5.5.   <a href="#rfc.section.5.5">EC-VRF Ciphersuites</a>
</li>
<li>5.6.   <a href="#rfc.section.5.6">When the EC-VRF Keys are Untrusted</a>
</li>
<ul><li>5.6.1.   <a href="#rfc.section.5.6.1">EC-VRF Validate Key</a>
</li>
</ul></ul><li>6.   <a href="#rfc.section.6">Implementation Status</a>
</li>
<li>7.   <a href="#rfc.section.7">Security Considerations</a>
</li>
<ul><li>7.1.   <a href="#rfc.section.7.1">Key Generation</a>
</li>
<ul><li>7.1.1.   <a href="#rfc.section.7.1.1">Uniqueness and collision resistance with untrusted keys</a>
</li>
<li>7.1.2.   <a href="#rfc.section.7.1.2">Pseudorandomness with untrusted keys</a>
</li>
</ul><li>7.2.   <a href="#rfc.section.7.2">Selective vs Full Pseudorandomness</a>
</li>
<li>7.3.   <a href="#rfc.section.7.3">Proper randomness for EC-VRF</a>
</li>
<li>7.4.   <a href="#rfc.section.7.4">Timing attacks</a>
</li>
</ul><li>8.   <a href="#rfc.section.8">Change Log</a>
</li>
<li>9.   <a href="#rfc.section.9">Contributors</a>
</li>
<li>10.   <a href="#rfc.references">References</a>
</li>
<ul><li>10.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>10.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#intro" id="intro">Introduction</a>
</h1>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> Rationale</h1>
<p id="rfc.section.1.1.p.1">A Verifiable Random Function (VRF) <a href="#MRV99" class="xref">[MRV99]</a> is the public-key version of a keyed cryptographic hash. Only the holder of the private VRF key can compute the hash, but anyone with corresponding public key can verify the correctness of the hash.  </p>
<p id="rfc.section.1.1.p.2">A key application of the VRF is to provide privacy against offline enumeration (e.g. dictionary attacks) on data  stored in a hash-based data structure.  In this application, a Prover holds the VRF private key and uses the VRF hashing to construct a hash-based data structure on the input data.  Due to the nature of the VRF, only the Prover can answer queries about whether or not some data is stored in the data structure.  Anyone who knows the public VRF key can verify that the Prover has answered the queries correctly. However no offline inferences (i.e. inferences without querying the Prover) can be made about the data stored in the data strucuture.  </p>
<h1 id="rfc.section.1.2">
<a href="#rfc.section.1.2">1.2.</a> Requirements</h1>
<p id="rfc.section.1.2.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119" class="xref">[RFC2119]</a>.  </p>
<h1 id="rfc.section.1.3">
<a href="#rfc.section.1.3">1.3.</a> Terminology</h1>
<p id="rfc.section.1.3.p.1">The following terminology is used through this document: </p>
<p></p>

<dl>
<dt>SK:</dt>
<dd style="margin-left: 8">The private key for the VRF.  </dd>
<dt>PK:</dt>
<dd style="margin-left: 8">The public key for the VRF.  </dd>
<dt>alpha:</dt>
<dd style="margin-left: 8">The input to be hashed by the VRF.  </dd>
<dt>beta:</dt>
<dd style="margin-left: 8">The VRF hash output.  </dd>
<dt>pi:</dt>
<dd style="margin-left: 8">The VRF proof.  </dd>
<dt>Prover:</dt>
<dd style="margin-left: 8">The Prover holds the private VRF key SK and public VRF key PK.  </dd>
<dt>Verifier:</dt>
<dd style="margin-left: 8">The Verifier holds the public VRF key PK.  </dd>
</dl>

<p> </p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> VRF Algorithms</h1>
<p id="rfc.section.2.p.1">A VRF comes with a key generation algorithm that generates a public VRF key PK and private VRF key SK.  </p>
<p id="rfc.section.2.p.2">A VRF hashes an input alpha using the private VRF key SK to obtain a VRF hash output beta </p>

<ul class="empty"><li>beta = VRF_hash(SK, alpha) </li></ul>

<p> The VRF_hash algorithm is deterministic, in the sense that it always produces the same output beta given a pair of inputs (SK, alpha).  The private key SK is also used to construct a proof pi that beta is the correct hash output </p>

<ul class="empty"><li>pi = VRF_prove(SK, alpha)</li></ul>

<p> The VRFs defined in this document allow anyone to deterministically obtain the VRF hash output beta directly from the proof value pi as </p>

<ul class="empty"><li>beta = VRF_proof2hash(pi)</li></ul>

<p> Notice that this means that </p>

<ul class="empty"><li>VRF_hash(SK, alpha) = VRF_proof2hash(VRF_prove(SK, alpha))</li></ul>

<p> The proof pi allows a Verifier holding the public key PK to verify that beta is the correct VRF hash of input alpha under key PK. Thus, the VRF also comes with an algorithm </p>

<ul class="empty"><li>VRF_verify(PK, alpha, pi)</li></ul>

<p> that outputs VALID if beta=VRF_proof2hash(pi) is correct VRF hash of alpha under key PK, and outputs INVALID otherwise.  </p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#secdef" id="secdef">VRF Security Properties</a>
</h1>
<p id="rfc.section.3.p.1">VRFs are designed to ensure the following security properties.  </p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> Full Uniqueness or Trusted Uniqueness</h1>
<p id="rfc.section.3.1.p.1">Uniqueness means that, for any fixed public VRF key and for any input alpha, there is a unique VRF output beta that can be proved to be valid.  Uniqueness must hold even for an adversarial Prover that knows the VRF private key SK.  </p>
<p id="rfc.section.3.1.p.2">"Full uniqueness" states that a computationally-bounded adversary cannot choose a VRF public key PK, a VRF input alpha, two different VRF hash outputs beta1 and beta2, and two proofs pi1 and pi2 such that VRF_verify(PK, alpha, pi1) and VRF_verify(PK, alpha, pi2) both output VALID.  </p>
<p id="rfc.section.3.1.p.3">A slightly weaker security property called "trusted uniquness" sufficies for many applications.  Trusted uniqueness is the same as full uniqueness, but it must hold only if the VRF keys PK and SK were generated in a trustworthy manner. In otherwords, uniqueness might not hold if keys were generated in an invalid manner or with bad randomness.  </p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> Full Collison Resistance or Trusted Collision Resistance</h1>
<p id="rfc.section.3.2.p.1">Like any cryprographic hash function, VRFs need to be collision resistant.  Collison resistance must hold even for an adversarial Prover that knows the VRF private key SK.  </p>
<p id="rfc.section.3.2.p.2">More percisely, "full collision resistance" states that it should be computationally infeasible for an adversary to find two distinct VRF inputs alpha1 and alpha2 that have the same VRF hash beta, even if that adversary knows the private VRF key SK.  </p>
<p id="rfc.section.3.2.p.3">For most applications, a slightly weaker security property called "trusted collision resistance" suffices.  Trusted collision resistance is the same as collision resistance, but it holds only if PK and SK were generated in a trustworthy manner.  </p>
<h1 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> <a href="#pseudodef" id="pseudodef">Full Pseudorandomness or Selective Pseudorandomness</a>
</h1>
<p id="rfc.section.3.3.p.1">Pseudorandomness ensures that when an adversarial Verifier sees a VRF hash output beta without its corresponding VRF proof pi, then beta is indistinguishable from a random value.  </p>
<p id="rfc.section.3.3.p.2">More percisely, suppose the public and private VRF keys (PK, SK) were generated in a trustworthy manner.  Pseudorandomness ensures that the VRF hash output beta (without its corresponding VRF proof pi) on any adversarially-chosen "target" VRF input alpha looks indistinguishable from random for any computationally bounded adversary who does not know the private VRF key SK.  This holds even if the adversary also gets to choose other VRF inputs alpha' and observe their corresponding VRF hash outputs beta' and proofs pi'.  </p>
<p id="rfc.section.3.3.p.3">With "full pseudorandomness", the adversary is allowed to choose the "target" VRF input  alpha at any time, even after it observes VRF outputs beta' and proofs pi' on a variety of chosen inputs alpha'.  </p>
<p id="rfc.section.3.3.p.4">"Selective pseudorandomness" is a weaker security property which suffices in many applications. Here, the adversary must choose the target VRF input alpha independently of the public VRF key PK, and before it  observes VRF outputs beta' and proofs pi' on inputs alpha' of its choice.  </p>
<p id="rfc.section.3.3.p.5">It is important to remember that the VRF output beta does not look random to the Prover, or to any other party that knows the private VRF key SK!  Such a party can easily distinguish beta from a random value by comparing beta to the result of VRF_hash(SK, alpha).  </p>
<p id="rfc.section.3.3.p.6">Also, the VRF output beta does not look random to any party that knows valid VRF proof pi corresponding to the VRF input alpha, even if this party does not know the private VRF key SK.  Such a party can easily distinguish beta from a random value by checking whether VRF_verify(PK, alpha, pi) returns "VALID" and beta = VRF_proof2hash(pi).  </p>
<p id="rfc.section.3.3.p.7">Also, the VRF output beta may not look random if VRF key generation was not done in a trustworthy fashion. (For example, if VRF keys were generated with bad randomness.) </p>
<h1 id="rfc.section.3.4">
<a href="#rfc.section.3.4">3.4.</a> An additional pseudorandomness property</h1>
<p id="rfc.section.3.4.p.1">[TODO:   The following property is not needed for applications that use VRFs to prevent enumeration of hash-based data structures.  However, we noticed that some other applications of VRF rely on this property.  As we have not yet found a formal definition of this property in the literature, we write it down here. ]</p>
<p id="rfc.section.3.4.p.2">Pseudorandomness, as defined in <a href="#pseudodef" class="xref">Section 3.3</a>, does not hold if the VRF keys were generated adversarially.  </p>
<p id="rfc.section.3.4.p.3">There is, however, a different type of pseudorandomness that could hold even if the VRF keys are generated adversarially, as long as the VRF input alpha is unpredictable.  Suppose the VRF keys are generated by an adversary.  Then, a VRF hash output beta should look pseudorandom to the adversary as long as (1) its corresponding VRF hash alpha is chosen randomly and independently of the VRF key, (2) alpha is unknown to the adversary, (3) the corresponding proof pi is unknown to the adversary, and (4) the VRF public key chosen by the adversary is valid.  </p>
<p id="rfc.section.3.4.p.4">[TODO: It should be possible to get the EC-VRF to satisfy this property, as long as verifiers run an VRF_validate_key() key function upon receipt of VRF public keys. However, we need to work out exactly what properties are needed from the VRF public keys in order for this property to hold. Some additional checks might need to be added to the ECVRF_validate_key() function.  Need to work out what are these checks.] </p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#fdh" id="fdh">RSA Full Domain Hash VRF (RSA-FDH-VRF)</a>
</h1>
<p id="rfc.section.4.p.1">The RSA Full Domain Hash  VRF (RSA-FDH-VRF) is a VRF that satisfies the "trusted uniqueness", "trusted collision resistance", and "full pseudorandomness" properties defined in <a href="#secdef" class="xref">Section 3</a>.  Its security follows from the standard RSA assumption in the random oracle model.  Formal security proofs are in <a href="#nsec5ecc" class="xref">[nsec5ecc]</a>.  </p>
<p id="rfc.section.4.p.2">The VRF computes the proof pi as a deterministic RSA signature on input alpha using the RSA Full Domain Hash Algorithm <a href="#RFC8017" class="xref">[RFC8017]</a> parametrized with the selected hash algorithm.  RSA signature verification is used to verify the correctness of the proof. The VRF hash output beta is simply obtained by hashing the proof pi with the selected hash algorithm.  </p>
<p id="rfc.section.4.p.3">The key pair for RSA-FDH-VRF MUST be generated in a way that it satisfies the conditions specified in Section 3 of <a href="#RFC8017" class="xref">[RFC8017]</a>.  </p>
<p id="rfc.section.4.p.4">In this document, the notation from <a href="#RFC8017" class="xref">[RFC8017]</a> is used.  </p>
<p id="rfc.section.4.p.5">Parameters used: </p>

<ul class="empty">
<li>(n, e) - RSA public key</li>
<li>K - RSA private key</li>
<li>k - length in octets of the RSA modulus n</li>
</ul>

<p> </p>
<p id="rfc.section.4.p.6">Fixed options: </p>

<ul class="empty">
<li>Hash - cryptographic hash function</li>
<li>hLen - output length in octets of hash function Hash</li>
</ul>

<p> </p>
<p id="rfc.section.4.p.7">Constraints on options: </p>

<ul class="empty"><li>Cryptographic security of Hash is at least as high as the cryptographic security level of the RSA key</li></ul>

<p> </p>
<p id="rfc.section.4.p.8">Primitives used: </p>

<ul class="empty">
<li>I2OSP - Coversion of a nonnegative integer to an octet string as defined in Section 4.1 of <a href="#RFC8017" class="xref">[RFC8017]</a> </li>
<li>OS2IP - Coversion of an octet string to a nonnegative integer as defined in Section 4.2 of <a href="#RFC8017" class="xref">[RFC8017]</a> </li>
<li>RSASP1 - RSA signature primitive as defined in Section 5.2.1 of <a href="#RFC8017" class="xref">[RFC8017]</a> </li>
<li>RSAVP1 - RSA verification primitive as defined in Section 5.2.2 of <a href="#RFC8017" class="xref">[RFC8017]</a> </li>
<li>MGF1 - Mask Generation Function based on a hash function as defined in Section B.2.1 of <a href="#RFC8017" class="xref">[RFC8017]</a> </li>
</ul>

<p> </p>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> RSA-FDH-VRF Proving</h1>
<p id="rfc.section.4.1.p.1">RSAFDHVRF_prove(K, alpha) </p>
<p id="rfc.section.4.1.p.2">Input: </p>

<ul class="empty">
<li>K - RSA private key</li>
<li>alpha - VRF hash input, an octet string</li>
</ul>

<p> </p>
<p id="rfc.section.4.1.p.3">Output: </p>

<ul class="empty"><li>pi - proof, an octet string of length k</li></ul>

<p> </p>
<p id="rfc.section.4.1.p.4">Steps: </p>

<ol>
<li>EM = MGF1(alpha, k - 1)</li>
<li>m = OS2IP(EM)</li>
<li>s = RSASP1(K, m)</li>
<li>pi = I2OSP(s, k)</li>
<li>Output pi</li>
</ol>

<p> </p>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> RSA-FDH-VRF Proof To Hash</h1>
<p id="rfc.section.4.2.p.1">RSAFDHVRF_proof2hash(pi) </p>
<p id="rfc.section.4.2.p.2">Input: </p>

<ul class="empty"><li>pi - proof, an octet string of length k</li></ul>

<p> </p>
<p id="rfc.section.4.2.p.3">Output: </p>

<ul class="empty"><li>beta - VRF hash output, an octet string of length hLen</li></ul>

<p> </p>
<p id="rfc.section.4.2.p.4">Steps: </p>

<ol>
<li>beta = Hash(pi)</li>
<li>Output beta</li>
</ol>

<p> </p>
<h1 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> RSA-FDH-VRF Verifying</h1>
<p id="rfc.section.4.3.p.1">RSAFDHVRF_verify((n, e), alpha, pi) </p>
<p id="rfc.section.4.3.p.2">Input: </p>

<ul class="empty">
<li>(n, e) - RSA public key</li>
<li>alpha - VRF hash input, an octet string</li>
<li>pi - proof to be verified, an octet string of length n</li>
</ul>

<p> </p>
<p id="rfc.section.4.3.p.3">Output: </p>

<ul class="empty"><li>"VALID" or "INVALID"</li></ul>

<p> </p>
<p id="rfc.section.4.3.p.4">Steps: </p>

<ol>
<li>s = OS2IP(pi)</li>
<li>m = RSAVP1((n, e), s)</li>
<li>EM = I2OSP(m, k - 1)</li>
<li>EM' = MGF1(alpha, k - 1)</li>
<li>If EM and EM' are equal, output "VALID"; else output "INVALID".  </li>
</ol>

<p> </p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#ecvrf" id="ecvrf">Elliptic Curve VRF (EC-VRF)</a>
</h1>
<p id="rfc.section.5.p.1">The Elliptic Curve Verifiable Random Function (EC-VRF) is a VRF that satisfies the trusted uniqueness, trusted collision resistance, and full pseudorandomness properties defined in <a href="#secdef" class="xref">Section 3</a>.  The security of this VRF follows from the decisional Diffie-Hellman (DDH) assumption in the random oracle model. Formal security proofs are in <a href="#nsec5ecc" class="xref">[nsec5ecc]</a>.  </p>
<p id="rfc.section.5.p.2">Fixed options: </p>

<ul class="empty">
<li>F - finite field</li>
<li>2n - length, in octets, of a field element in F</li>
<li>E - elliptic curve (EC) defined over F</li>
<li>m - length, in octets, of an EC point encoded as an octet string</li>
<li>G - subgroup of E of large prime order</li>
<li>q - prime order of group G</li>
<li>cofactor - number of points on E divided by q</li>
<li>g - generator of group G</li>
<li>Hash - cryptographic hash function</li>
<li>hLen - output length in octets of Hash</li>
</ul>

<p> </p>
<p id="rfc.section.5.p.3">Constraints on options: </p>

<ul class="empty">
<li>Field elements in F have bit lengths divisible by 16</li>
<li>hLen is equal to 2n</li>
</ul>

<p> </p>
<p id="rfc.section.5.p.4">Parameters used (the generation of these parameters is specified in <a href="#suites" class="xref">Section 5.5</a>): </p>

<ul class="empty">
<li>SK - VRF private key</li>
<li>x - VRF secret scalar, an integer where 0 &lt; x &lt; q <ul class="empty"><li>Note: depending on the ciphersuite used, the VRF secret scalar may be equal to SK; else, it is derived from SK </li></ul>
<p> </p>
</li>
<li>y = g^x - VRF public key, an EC point</li>
</ul>

<p> </p>
<p id="rfc.section.5.p.5">Notation and primitives used: </p>

<ul class="empty">
<li>p^k - when p is an EC point: point multiplication, i.e. k repetitions of group operation on EC point p. when p is an integer: exponentiation </li>
<li>|| - octet string concatenation</li>
<li>I2OSP - nonnegative integer conversion to octet string as defined in Section 4.1 of <a href="#RFC8017" class="xref">[RFC8017]</a>
</li>
<li>OS2IP - Coversion of an octet string to a nonnegative integer as defined in Section 4.2 of <a href="#RFC8017" class="xref">[RFC8017]</a>
</li>
<li>EC2OSP - conversion of EC point to an m-octet string as specified in <a href="#suites" class="xref">Section 5.5</a>
</li>
<li>OS2ECP - conversion of an m-octet string to EC point as specified in <a href="#suites" class="xref">Section 5.5</a>.  OS2ECP returns INVALID if the octet string does not convert to a valid EC point.</li>
<li>RS2ECP - conversion of a random 2n-octet string to an EC point as specified in <a href="#suites" class="xref">Section 5.5</a>
</li>
<li>ECVRF_hash_to_curve - [TODO: Explain]</li>
<li>ECVRF_nonce_generation - [TODO: Explain] as specified in <a href="#suites" class="xref">Section 5.5</a>
</li>
<li>ECVRF_hash_points - [TODO: Explain]</li>
</ul>

<p> </p>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#ecvrfprove" id="ecvrfprove">EC-VRF Proving</a>
</h1>
<p id="rfc.section.5.1.p.1">Note: this function must have the VRF private key SK as input. Below we make it more efficient by supplying it also with the secret scalar x and the public key y as additional inputs; however, each of these can be computed from SK if desired.  </p>
<p id="rfc.section.5.1.p.2">ECVRF_prove(y, x, alpha) </p>
<p id="rfc.section.5.1.p.3">Input: </p>

<ul class="empty">
<li>SK - VRF private key</li>
<li>x - VRF secret scalar</li>
<li>y = g^x - VRF public key</li>
</ul>

<p> </p>
<p id="rfc.section.5.1.p.4">Output: </p>

<ul class="empty"><li>pi - VRF proof, octet string of length m+3n</li></ul>

<p> </p>
<p id="rfc.section.5.1.p.5">Steps: </p>

<ol>
<li>h = ECVRF_hash_to_curve(y, alpha)</li>
<li>gamma = h^x</li>
<li>k = ECVRF_nonce_generation(SK, alpha)</li>
<li>c = ECVRF_hash_points(g, h, y, gamma, g^k, h^k)</li>
<li>s = k + c*x mod q (where * denotes integer multiplication)</li>
<li>pi = EC2OSP(gamma) || I2OSP(c, n) || I2OSP(s, 2n)</li>
<li>Output pi</li>
</ol>

<p> </p>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> EC-VRF Proof To Hash</h1>
<p id="rfc.section.5.2.p.1">ECVRF_proof2hash(pi) </p>
<p id="rfc.section.5.2.p.2">Input: </p>

<ul class="empty"><li>pi - VRF proof, octet string of length m+3n</li></ul>

<p> </p>
<p id="rfc.section.5.2.p.3">Output: </p>

<ul class="empty">
<li>"INVALID", or </li>
<li>beta - VRF hash output, octet string of length 2n</li>
</ul>

<p> </p>
<p id="rfc.section.5.2.p.4">Steps: </p>

<ol>
<li>D = ECVRF_decode_proof(pi)</li>
<li>If D is "INVALID", output "INVALID" and stop</li>
<li>(gamma, c, s) = D</li>
<li>beta = Hash(EC2OSP(gamma^cofactor))</li>
<li>Output beta</li>
</ol>

<p> </p>
<h1 id="rfc.section.5.3">
<a href="#rfc.section.5.3">5.3.</a> EC-VRF Verifying</h1>
<p id="rfc.section.5.3.p.1">ECVRF_verify(y, pi, alpha) </p>
<p id="rfc.section.5.3.p.2">Input: </p>

<ul class="empty">
<li>y -  public key, an EC point</li>
<li>pi - VRF proof, octet string of length 5n+1</li>
<li>alpha - VRF input, octet string</li>
</ul>

<p> </p>
<p id="rfc.section.5.3.p.3">Output: </p>

<ul class="empty"><li>"VALID" or "INVALID"</li></ul>

<p> </p>
<p id="rfc.section.5.3.p.4">Steps: </p>

<ol>
<li>D = ECVRF_decode_proof(pi)</li>
<li>If D is "INVALID", output "INVALID" and stop</li>
<li>(gamma, c, s) = D</li>
<li>u = y^c * g^s (where * denotes EC point addition, i.e. a group operation on two EC points)</li>
<li>h = ECVRF_hash_to_curve(y, alpha)</li>
<li>v = gamma^c / h^s (where / denotes EC point subtraction)</li>
<li>c' = ECVRF_hash_points(g, h, y, gamma, u, v)</li>
<li>If c and c' are equal, output "VALID"; else output "INVALID" </li>
</ol>

<p> </p>
<p id="rfc.section.5.3.p.5">[TODO: We could hash alpha instead of gamma. Doing so costs more because alpha is longer, but may help salvage some security if ECVRF_hash_to_curve is broken and not collision-resistant. Need to analyze exact security preserved and decide if the tradeoff is worth it.] </p>
<h1 id="rfc.section.5.4">
<a href="#rfc.section.5.4">5.4.</a> EC-VRF Auxiliary Functions</h1>
<p id="rfc.section.5.4.p.1">[TODO: analyze whether domain separation for hash functions used here matters and if so how to ensure we have it.] </p>
<h1 id="rfc.section.5.4.1">
<a href="#rfc.section.5.4.1">5.4.1.</a> <a href="#ecvrfH2C" id="ecvrfH2C">EC-VRF Hash To Curve</a>
</h1>
<p id="rfc.section.5.4.1.p.1">The ECVRF_hash_to_curve algorithm takes in an octet string alpha and converts it to h, an EC point in G. </p>
<h1 id="rfc.section.5.4.1.1">
<a href="#rfc.section.5.4.1.1">5.4.1.1.</a> <a href="#ecvrfH2C1" id="ecvrfH2C1">ECVRF_hash_to_curve1</a>
</h1>
<p id="rfc.section.5.4.1.1.p.1">The following ECVRF_hash_to_curve1(y, alpha) algorithm implements ECVRF_hash_to_curve in a simple and generic way that works for any elliptic curve.  </p>
<p id="rfc.section.5.4.1.1.p.2">The running time of this algorithm depends on alpha.  For the ciphersuites specified in <a href="#suites" class="xref">Section 5.5</a>, this algorithm is expected to find a valid curve point after approximately two attempts (i.e., when ctr=1) on average. See also <a href="#Icart09" class="xref">[Icart09]</a>.  </p>
<p id="rfc.section.5.4.1.1.p.3">However, because the running time of algorithm depends on alpha, this algorithm SHOULD be avoided in applications where it is important that the VRF input alpha remain secret.  </p>
<p id="rfc.section.5.4.1.1.p.4">ECVRF_hash_to_curve1(y, alpha) </p>
<p id="rfc.section.5.4.1.1.p.5">Input: </p>

<ul class="empty">
<li>alpha - value to be hashed, an octet string</li>
<li>y - public key, an EC point</li>
</ul>

<p> </p>
<p id="rfc.section.5.4.1.1.p.6">Output: </p>

<ul class="empty"><li>h - hashed value, a finite EC point in G</li></ul>

<p> </p>
<p id="rfc.section.5.4.1.1.p.7">Steps: </p>

<ol>
<li>ctr = 0</li>
<li>pk = EC2OSP(y)</li>
<li>h = "INVALID"</li>
<li>While h is "INVALID" or h is EC point at infinity: <ol style="list-style-type: upper-alpha">
<li>CTR = I2OSP(ctr, 4)</li>
<li>ctr = ctr + 1</li>
<li>attempted_hash = Hash(pk || alpha || CTR)</li>
<li>h = RS2ECP(attempted_hash)</li>
<li>If h is not "INVALID" and cofactor &gt; 1, set h = h^cofactor</li>
</ol>
</li>
<li>Output h</li>
</ol>

<p> </p>
<h1 id="rfc.section.5.4.1.2">
<a href="#rfc.section.5.4.1.2">5.4.1.2.</a> ECVRF_hash_to_curve2</h1>
<p id="rfc.section.5.4.1.2.p.1">For applications where VRF input alpha must be kept secret, the following ECVRF_hash_to_curve algorithm MAY be used to used as generic way to hash an octet string onto any elliptic curve.  </p>
<p id="rfc.section.5.4.1.2.p.2">[TODO: We should look into specifying the generic deterministic time hash_to_curve algorithm from <a href="#Icart09" class="xref">[Icart09]</a>.  We should also consider Shallue-Woestijne-Ulas algorithm from <a href="#BCIMRT10" class="xref">[BCIMRT10]</a> as well as Elligator (for Ed25519) and Elligator Squared for more general curves. Some of these options are summarized in an upcoming draft <a href="#SW18" class="xref">[SW18]</a>.] </p>
<h1 id="rfc.section.5.4.1.3">
<a href="#rfc.section.5.4.1.3">5.4.1.3.</a> ECVRF_hash_to_curve_elligator2_25519</h1>
<p id="rfc.section.5.4.1.3.p.1">ECVRF_hash_to_curve_elligator2_25519(y, alpha) </p>
<p id="rfc.section.5.4.1.3.p.2">Input: </p>

<ul class="empty">
<li>alpha - value to be hashed, an octet string</li>
<li>y - public key, an EC point</li>
</ul>

<p> </p>
<p id="rfc.section.5.4.1.3.p.3">Output: </p>

<ul class="empty"><li>h - hashed value, a finite EC point in G <a href="#RFC8032" class="xref">RFC8032 Section 5.1.2</a>
</li></ul>

<p> </p>
<p id="rfc.section.5.4.1.3.p.4">Fixed options: </p>

<ul class="empty">
<li>p = 2^255-19, the size of the finite field F, a prime, for Curve25519</li>
<li>A = 486662, Montgomery curve constant for Curve25519 </li>
<li>cofactor = 8 , the cofactor for Curve25519 </li>
</ul>

<p> </p>
<p id="rfc.section.5.4.1.3.p.5">Steps: </p>

<ol>
<li>pk = EC2OSP(y)</li>
<li>hash = Hash(pk || alpha )</li>
<li>r = first 2n octects of hash</li>
<li>x_0 = next unused bit of hash </li>
<li>u = - A / (1 + 2*(r^2) )  mod p (where * denotes integer multiplication)</li>
<li>v = u * (u^2 + A*u + 1) mod p </li>
<li>e = v ^ ((p-1)/2) mod p </li>
<li>if v is equal to -1 then finalu = -A - u; else finalu = u </li>
<li>y = (finalu - 1) / (finalu + 1)</li>
<li>let h = (x_0,y), an EC point per the encoding in <a href="#RFC8032" class="xref">RFC8032 Section 5.1.2</a>
</li>
<li>h = h^cofactor</li>
</ol>

<p> </p>
<h1 id="rfc.section.5.4.2">
<a href="#rfc.section.5.4.2">5.4.2.</a> EC-VRF Nonce Generation</h1>
<p id="rfc.section.5.4.2.p.1">k = ECVRF_nonce_generation(SK, alpha)</p>
<p id="rfc.section.5.4.2.p.2">[TODO: specify as per RFC 8032 for 25519 or as per RFC 6979 for other curves]</p>
<h1 id="rfc.section.5.4.3">
<a href="#rfc.section.5.4.3">5.4.3.</a> EC-VRF Hash Points</h1>
<p id="rfc.section.5.4.3.p.1">ECVRF_hash_points(p_1, p_2, ..., p_j) </p>
<p id="rfc.section.5.4.3.p.2">Input: </p>

<ul class="empty"><li>p_i - EC point in G</li></ul>

<p> </p>
<p id="rfc.section.5.4.3.p.3">Output: </p>

<ul class="empty"><li>h - hash value, integer between 0 and 2^(8n)-1</li></ul>

<p> </p>
<p id="rfc.section.5.4.3.p.4">Steps: </p>

<ol>
<li>P = empty octet string</li>
<li>for p_i in [p_1, p_2, ... p_j]: <br>P = P || EC2OSP(p_i) </li>
<li>h1 = Hash(P)</li>
<li>h2 = first n octets of h1</li>
<li>h = OS2IP(h2)</li>
<li>Output h</li>
</ol>

<p> </p>
<h1 id="rfc.section.5.4.4">
<a href="#rfc.section.5.4.4">5.4.4.</a> EC-VRF Decode Proof</h1>
<p id="rfc.section.5.4.4.p.1">ECVRF_decode_proof(pi) </p>
<p id="rfc.section.5.4.4.p.2">Input: </p>

<ul class="empty"><li>pi - VRF proof, octet string (m+3n octets)</li></ul>

<p> </p>
<p id="rfc.section.5.4.4.p.3">Output: </p>

<ul class="empty">
<li>"INVALID", or </li>
<li>gamma - EC point</li>
<li>c - integer between 0 and 2^(8n)-1 </li>
<li>s - integer between 0 and 2^(16n)-1 </li>
</ul>

<p> </p>
<p id="rfc.section.5.4.4.p.4">Steps: </p>

<ol>
<li>let gamma', c', s' be pi split after m-th and m+n-th octet</li>
<li>gamma = OS2ECP(gamma')</li>
<li>if gamma = "INVALID" output "INVALID" and stop.</li>
<li>c = OS2IP(c')</li>
<li>s = OS2IP(s')</li>
<li>Output gamma, c, and s</li>
</ol>

<p> </p>
<h1 id="rfc.section.5.5">
<a href="#rfc.section.5.5">5.5.</a> <a href="#suites" id="suites">EC-VRF Ciphersuites</a>
</h1>
<p id="rfc.section.5.5.p.1">This document defines EC-VRF-P256-SHA256 as follows: </p>

<ul>
<li>The EC group G is the NIST-P256 elliptic curve, with curve parameters as specified in <a href="#FIPS-186-3" class="xref">[FIPS-186-3]</a> (Section D.1.2.3) and <a href="#RFC5114" class="xref">[RFC5114]</a>  (Section 2.6). For this group, 2n = 32 and cofactor = 1.  </li>
<li>The key pair generation primitive is specified in Section 3.2.1 of <a href="#SECG1" class="xref">[SECG1]</a>. </li>
<li>EC2OSP is specified in Section 2.3.3 of <a href="#SECG1" class="xref">[SECG1]</a> with point compression on.  This implies m = 2n + 1 = 33.  </li>
<li>OS2ECP is specified in Section 2.3.4 of <a href="#SECG1" class="xref">[SECG1]</a>.  </li>
<li>RS2ECP(h) = OS2ECP(0x02 || h). The input h is a 32-octet string and the output is either an EC point or "INVALID". </li>
<li>The hash function Hash is SHA-256 as specified in <a href="#RFC6234" class="xref">[RFC6234]</a>.  </li>
<li>The ECVRF_hash_to_curve function is as specified in <a href="#ecvrfH2C1" class="xref">Section 5.4.1.1</a>.  </li>
</ul>

<p> </p>
<p id="rfc.section.5.5.p.2">This document defines EC-VRF-ED25519-SHA256 as follows: </p>

<ul>
<li>The EC group G is the Ed25519 elliptic curve with parameters defined in Table 1 of <a href="#RFC8032" class="xref">[RFC8032]</a>.  For this group, 2n = 32 and cofactor = 8.  </li>
<li>The private key and generation of the secret scalar and the public key are specified in Section 5.1.5 of <a href="#RFC8032" class="xref">[RFC8032]</a>
</li>
<li>The ECVRF_nonce_generation function is as specified in Section 5.1.6 Steps 1-2 of <a href="#RFC8032" class="xref">[RFC8032]</a>[TODO: What should F and C be? Should we have a prehash version also?]</li>
<li>EC2OSP is specified in Section 5.1.2 of <a href="#RFC8032" class="xref">[RFC8032]</a>. This implies m = 2n = 32.</li>
<li>OS2ECP is specified in Section 5.1.3 of <a href="#RFC8032" class="xref">[RFC8032]</a>.  </li>
<li>RS2ECP is equivalent to OS2ECP.</li>
<li>The hash function Hash is SHA-256 as specified in <a href="#RFC6234" class="xref">[RFC6234]</a>.  </li>
<li>The ECVRF_hash_to_curve function is as specified in <a href="#ecvrfH2C1" class="xref">Section 5.4.1.1</a>.  </li>
</ul>

<p> </p>
<p id="rfc.section.5.5.p.3">[TODO: Should we add an EC-VRF-ED25519-SHA256-Elligator ciphersuite where the Elligator hash function is used for ECVRF_hash-to-curve? Should we add Elligator-Squared? We may want to consider options in the upcoming draft <a href="#SW18" class="xref">[SW18]</a>.] </p>
<p id="rfc.section.5.5.p.4">[TODO: Add an Ed448 ciphersuite? This is probably not needed...]</p>
<p id="rfc.section.5.5.p.5">[NOTE: In the unlikely case that future versions of this spec use a elliptic curve group G that does not also come with a specification of the group generator g, then we can still have full uniqueness and full collision resistance by adding an check to ECVRF_validate_key(PK) that ensures that g is a point on the elliptic curve and g^cofactor is not the EC point at infinity.] </p>
<h1 id="rfc.section.5.6">
<a href="#rfc.section.5.6">5.6.</a> <a href="#keycheck" id="keycheck">When the EC-VRF Keys are Untrusted</a>
</h1>
<p id="rfc.section.5.6.p.1">The EC-VRF as specified above is a VRF that satisfies the "trusted uniqueness", "trusted collision resistance", and "full pseudorandomness" properties defined in <a href="#secdef" class="xref">Section 3</a>.  If the elliptic curve parameters (including the generator g) are trusted, but the VRF public key PK is not trusted, this VRF can be modified to additionally satisfy "full uniqueness", and "full collision resistance".  This is done by additionally requiring the Verifier to perform the following validation procedure upon receipt of the public VRF key.  </p>
<p id="rfc.section.5.6.p.2">The Verifier MUST perform this validation procedure when the entity that generated the public VRF key is untrusted.  The public key MUST NOT be used if this procedure returns "INVALID".  Note well that this procedure is not sufficient if the elliptic curve E or if g, the generator of group G, is untrusted.  </p>
<p id="rfc.section.5.6.p.3">This procedure supposes that the public key provided to the Verifier is an octet string. The procedure returns "INVALID" if the public key in invalid.  Otherwise, it returns y, the public key as an EC point.  </p>
<h1 id="rfc.section.5.6.1">
<a href="#rfc.section.5.6.1">5.6.1.</a> EC-VRF Validate Key</h1>
<p id="rfc.section.5.6.1.p.1">ECVRF_validate_key(PK) </p>
<p id="rfc.section.5.6.1.p.2">Input: </p>

<ul class="empty"><li>PK - public key, an octet string</li></ul>

<p> </p>
<p id="rfc.section.5.6.1.p.3">Output: </p>

<ul class="empty">
<li>"INVALID", or </li>
<li>y - public key, an EC point</li>
</ul>

<p> </p>
<p id="rfc.section.5.6.1.p.4">Steps: </p>

<ol>
<li>y = OS2ECP(PK)</li>
<li>If y is "INVALID", output "INVALID" and stop</li>
<li>If y^cofactor is the EC point at infinty, output "INVALID" and stop</li>
<li>Output y</li>
</ol>

<p> </p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#imp" id="imp">Implementation Status</a>
</h1>
<p id="rfc.section.6.p.1">An implementation of the RSA-FDH-VRF (SHA-256) and EC-VRF-P256-SHA256 was first developed as a part of the NSEC5 project <a href="#I-D.vcelak-nsec5" class="xref">[I-D.vcelak-nsec5]</a> and is available at <span>&lt;</span><a href="http://github.com/fcelda/nsec5-crypto">http://github.com/fcelda/nsec5-crypto</a><span>&gt;</span>.  The EC-VRF implementation may be out of date as this spec has evolved.  </p>
<p id="rfc.section.6.p.2">The Key Transparency project at Google uses a VRF implemention that is similar to the EC-VRF-P256-SHA256, with a few minor changes including the use of SHA-512 instead of SHA-256. Its implementation is available <span>&lt;</span><a href="https://github.com/google/keytransparency/blob/master/core/vrf/vrf.go">https://github.com/google/keytransparency/blob/master/core/vrf/vrf.go</a><span>&gt;</span> </p>
<p id="rfc.section.6.p.3">An implementation by Yahoo! similar to the EC-VRF is available at <span>&lt;</span><a href="https://github.com/r2ishiguro/vrf">https://github.com/r2ishiguro/vrf</a><span>&gt;</span>.  </p>
<p id="rfc.section.6.p.4">An implementation similar to EC-VRF is available as part of the CONIKS implementation in Golang at <span>&lt;</span><a href="https://github.com/coniks-sys/coniks-go/tree/master/crypto/vrf">https://github.com/coniks-sys/coniks-go/tree/master/crypto/vrf</a><span>&gt;</span>.  </p>
<p id="rfc.section.6.p.5">Open Whisper Systems also uses a VRF very similar to EC-VRF-ED25519-SHA512-Elligator, called VXEdDSA, and specified here: <span>&lt;</span><a href="https://whispersystems.org/docs/specifications/xeddsa/">https://whispersystems.org/docs/specifications/xeddsa/</a><span>&gt;</span> </p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#securitycons" id="securitycons">Security Considerations</a>
</h1>
<h1 id="rfc.section.7.1">
<a href="#rfc.section.7.1">7.1.</a> Key Generation</h1>
<p id="rfc.section.7.1.p.1">Applications that use the VRFs defined in this document MUST ensure that that the VRF key is generated correctly, using good randomness.  </p>
<h1 id="rfc.section.7.1.1">
<a href="#rfc.section.7.1.1">7.1.1.</a> Uniqueness and collision resistance with untrusted keys</h1>
<p id="rfc.section.7.1.1.p.1">The EC-VRF as specified in <a href="#ecvrfprove" class="xref">Section 5.1</a>-<a href="#suites" class="xref">Section 5.5</a> statisfies the "trusted uniqueness" and "trusted collision resistance" properties as long as the VRF keys are generated correctly, with good randomness.  If the Verifier trusts the VRF keys are generated correctly, it MAY use the public key y as is.  </p>
<p id="rfc.section.7.1.1.p.2">However, if the EC-VRF uses keys that could be generated adversarially, then the the Verfier MUST first perform the validation procedure ECVRF_validate_key(PK) (specified in <a href="#keycheck" class="xref">Section 5.6</a>)  upon receipt of the public key PK as an octet string.  If the validation procedure outputs "INVALID", then the public key MUST not be used.  Otherwise, the procedure will output a valid public key y, and the EC-VRF with public key y satisfies the "full uniqueness" and "full collision resistance" properties.  </p>
<p id="rfc.section.7.1.1.p.3">The RSA-FDH-VRF statisfies the "trusted uniqueness" and "trusted collision resistance" properties as long as the VRF keys are generated correctly, with good randomness.  These properties may not hold if the keys are generated adversarially (e.g., if RSA is not permutation). Meanwhile, the "full uniqueness" and "full collision resistance" are properties that hold  even if VRF keys are generated by an adversary.  The RSA-FDH-VRF defined in this document does not have these properties.  However, if adversarial key generation is a concern, the RSA-FDH-VRF may be modifed to have these properties by adding additional cryptographic checks that its public key has the right form.  These modifications are left for future specification.  </p>
<h1 id="rfc.section.7.1.2">
<a href="#rfc.section.7.1.2">7.1.2.</a> Pseudorandomness with untrusted keys</h1>
<p id="rfc.section.7.1.2.p.1">Without good randomness, the "pseudorandomness" properties of the VRF may not hold. Note that it is not possible to guarantee pseudorandomness in the face of adversarially generated VRF keys.  This is because an adversary can always use bad randomness to generate the VRF keys, and thus, the VRF output may not be pseudorandom.  </p>
<h1 id="rfc.section.7.2">
<a href="#rfc.section.7.2">7.2.</a> Selective vs Full Pseudorandomness</h1>
<p><a href="#nsec5ecc" class="xref">[nsec5ecc]</a> presents cryptographic reductions to an underlying hard problem (e.g. Decisional Diffie Hellman for the EC-VRF, or the standard RSA assumption for RSA-FDH-VRF) that prove the VRFs specificied in this document possess full pseudorandomness as well as selective pseudorandomness.  However, the cryptographic reductions are tighter for selective pseudorandomness than for full pseudorandomness.  This means the the VRFs have quantitavely stronger security guarentees for selective pseudorandomness.  </p>
<p id="rfc.section.7.2.p.2">Applications that are concerned about tightness of cryptographic reductions therefore have two options.  </p>

<ul>
<li>They may choose to ensure that selective pseudorandomness is sufficient for the application. That is, that pseudorandomness of outputs matters only for inputs that are chosen independently of the VRF key.  </li>
<li>If full pseudorandomness is required for the application, the application may increase security parameters to make up for the loose security reduction.  For RSA-FDH-VRF, this means increasing the RSA key length. For EC-VRF, this means increasing the cryptographic strength of the EC group G. For both RSA-FDH-VRF and EC-VRF the cryptographic strength of the hash function Hash may also potentially need to be increased.  </li>
</ul>

<p> </p>
<h1 id="rfc.section.7.3">
<a href="#rfc.section.7.3">7.3.</a> Proper randomness for EC-VRF</h1>
<p id="rfc.section.7.3.p.1">Applications that use the EC-VRF defined in this document MUST ensure that the random nonce k used in the ECVRF_prove algorithm is chosen with proper randomness. Otherwise, an adversary may be able to recover the private VRF key x (and thus break pseudorandomness of the VRF) after observing several valid VRF proofs pi.  </p>
<p id="rfc.section.7.3.p.2">[TODO: In the next version of the draft we should add a specification for nonce generation.] </p>
<h1 id="rfc.section.7.4">
<a href="#rfc.section.7.4">7.4.</a> Timing attacks</h1>
<p id="rfc.section.7.4.p.1">The EC-VRF_hash_to_curve algorithm defined in <a href="#ecvrfH2C1" class="xref">Section 5.4.1.1</a> SHOULD NOT be used in applications where the VRF input alpha is secret and is hashed by the VRF on-the-fly.  This is because the EC-VRF_hash_to_curve algorithm's running time depends on the VRF input alpha, and thus creates a timing channel that can be used to learn information about alpha.  That said, for most inputs the amount of information obtained from such a timing attack is likely to be small (1 bit, on average), since the algorithm is expected to find a valid curve point after only two attempts.  However, there might be inputs which cause the algorithm to make many attempts before it finds a valid curve point; for such inputs, the information leaked in a timing attack will be more than 1 bit.  </p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> Change Log</h1>
<p id="rfc.section.8.p.1">Note to RFC Editor: if this document does not obsolete an existing RFC, please remove this appendix before publication as an RFC.  </p>
<p></p>

<ul class="empty">
<li>00 - Forked this document from draft-goldbe-vrf-01.</li>
<li>01 - Minor updates, mostly highlighting TODO items.</li>
</ul>

<p> </p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> Contributors</h1>
<p id="rfc.section.9.p.1">This document also would not be possible without the work of Moni Naor (Weizmann Institute), Sachin Vasant (Cisco Systems), and Asaf Ziv (Facebook).  Shumon Huque (Salesforce) and David C. Lawerence (Akamai) provided valuable input to this draft.  </p>
<h1 id="rfc.references">
<a href="#rfc.references">10.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">10.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="FIPS-186-3">[FIPS-186-3]</b></td>
<td class="top">
<a>National Institute for Standards and Technology</a>, "<a>Digital Signature Standard (DSS)</a>", FIPS PUB 186-3, June 2009.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5114">[RFC5114]</b></td>
<td class="top">
<a>Lepinski, M.</a> and <a>S. Kent</a>, "<a href="https://tools.ietf.org/html/rfc5114">Additional Diffie-Hellman Groups for Use with IETF Standards</a>", RFC 5114, DOI 10.17487/RFC5114, January 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6234">[RFC6234]</b></td>
<td class="top">
<a>Eastlake 3rd, D.</a> and <a>T. Hansen</a>, "<a href="https://tools.ietf.org/html/rfc6234">US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)</a>", RFC 6234, DOI 10.17487/RFC6234, May 2011.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8017">[RFC8017]</b></td>
<td class="top">
<a>Moriarty, K.</a>, <a>Kaliski, B.</a>, <a>Jonsson, J.</a> and <a>A. Rusch</a>, "<a href="https://tools.ietf.org/html/rfc8017">PKCS #1: RSA Cryptography Specifications Version 2.2</a>", RFC 8017, DOI 10.17487/RFC8017, November 2016.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8032">[RFC8032]</b></td>
<td class="top">
<a>Josefsson, S.</a> and <a>I. Liusvaara</a>, "<a href="https://tools.ietf.org/html/rfc8032">Edwards-Curve Digital Signature Algorithm (EdDSA)</a>", RFC 8032, DOI 10.17487/RFC8032, January 2017.</td>
</tr>
<tr>
<td class="reference"><b id="SECG1">[SECG1]</b></td>
<td class="top">
<a>Standards for Efficient Cryptography Group (SECG)</a>, "<a href="http://www.secg.org/sec1-v2.pdf">SEC 1: Elliptic Curve Cryptography</a>", Version 2.0, May 2009.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">10.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="BCIMRT10">[BCIMRT10]</b></td>
<td class="top">
<a>Brier, E.</a>, <a>Coron, J.</a>, <a>Icart, T.</a>, <a>Madore, D.</a>, <a>Randriam, H.</a> and <a>M. Tibouchi</a>, "<a>Efficient Indifferentiable Hashing into Ordinary Elliptic Curves</a>", in CRYPTO, 2010.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.vcelak-nsec5">[I-D.vcelak-nsec5]</b></td>
<td class="top">
<a>Vcelak, J.</a>, <a>Goldberg, S.</a>, <a>Papadopoulos, D.</a>, <a>Huque, S.</a> and <a>D. Lawrence</a>, "<a href="https://tools.ietf.org/html/draft-vcelak-nsec5-06">NSEC5, DNSSEC Authenticated Denial of Existence</a>", Internet-Draft draft-vcelak-nsec5-06, January 2018.</td>
</tr>
<tr>
<td class="reference"><b id="Icart09">[Icart09]</b></td>
<td class="top">
<a>Icart, T.</a>, "<a>How to Hash into Elliptic Curves</a>", in CRYPTO, 2009.</td>
</tr>
<tr>
<td class="reference"><b id="MRV99">[MRV99]</b></td>
<td class="top">
<a>Michali, S.</a>, <a>Rabin, M.</a> and <a>S. Vadhan</a>, "<a>Verifiable Random Functions</a>", in FOCS, 1999.</td>
</tr>
<tr>
<td class="reference"><b id="nsec5ecc">[nsec5ecc]</b></td>
<td class="top">
<a>Papadopoulos, D.</a>, <a>Wessels, D.</a>, <a>Huque, S.</a>, <a>Vcelak, J.</a>, <a>Naor, M.</a>, <a>Reyzin, L.</a> and <a>S. Goldberg</a>, "<a href="https://eprint.iacr.org/2017/099.pdf">Making NSEC5 Practical for DNSSEC</a>", in ePrint Cryptology Archive 2017/099, February 2017.</td>
</tr>
<tr>
<td class="reference"><b id="SW18">[SW18]</b></td>
<td class="top">
<a>Sullivan, E.</a> and <a>C. Wood</a>, "<a>Hashing to Elliptic Curves</a>", 2018.</td>
</tr>
</tbody></table>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Sharon Goldberg</span> 
	  <span class="n hidden">
		<span class="family-name">Goldberg</span>
	  </span>
	</span>
	<span class="org vcardline">Boston University</span>
	<span class="adr">
	  <span class="vcardline">111 Cummington St, MCS135</span>

	  <span class="vcardline">
		<span class="locality">Boston</span>,  
		<span class="region">MA</span> 
		<span class="code">02215</span>
	  </span>
	  <span class="country-name vcardline">USA</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:goldbe@cs.bu.edu">goldbe@cs.bu.edu</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Leonid Reyzin</span> 
	  <span class="n hidden">
		<span class="family-name">Reyzin</span>
	  </span>
	</span>
	<span class="org vcardline">Boston University</span>
	<span class="adr">
	  <span class="vcardline">111 Cummington St, MCS135</span>

	  <span class="vcardline">
		<span class="locality">Boston</span>,  
		<span class="region">MA</span> 
		<span class="code">02215</span>
	  </span>
	  <span class="country-name vcardline">USA</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:reyzin@bu.edu">reyzin@bu.edu</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Dimitrios Papadopoulos</span> 
	  <span class="n hidden">
		<span class="family-name">Papadopoulos</span>
	  </span>
	</span>
	<span class="org vcardline">Hong Kong University of Science and Techology</span>
	<span class="adr">
	  <span class="vcardline">Clearwater Bay</span>

	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Hong Kong</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:dipapado@cse.ust.hkbu.edu">dipapado@cse.ust.hkbu.edu</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Jan Vcelak</span> 
	  <span class="n hidden">
		<span class="family-name">Vcelak</span>
	  </span>
	</span>
	<span class="org vcardline">NS1</span>
	<span class="adr">
	  <span class="vcardline">16 Beaver St</span>

	  <span class="vcardline">
		<span class="locality">New York</span>,  
		<span class="region">NY</span> 
		<span class="code">10004</span>
	  </span>
	  <span class="country-name vcardline">USA</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:jvcelak@ns1.com">jvcelak@ns1.com</a></span>

  </address>
</div>

</body>
</html>
