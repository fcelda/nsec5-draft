<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Verifiable Random Functions (VRFs)</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Rationale">
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 Requirements">
<link href="#rfc.section.1.3" rel="Chapter" title="1.3 Terminology">
<link href="#rfc.section.2" rel="Chapter" title="2 VRF Algorithms">
<link href="#rfc.section.3" rel="Chapter" title="3 VRF Security Properties">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Full Uniqueness or Trusted Uniqueness">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Full Collison Resistance or Trusted Collision Resistance">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Full Pseudorandomness or Selective Pseudorandomness">
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 A random-oracle-like unpredictability property">
<link href="#rfc.section.4" rel="Chapter" title="4 RSA Full Domain Hash VRF (RSA-FDH-VRF)">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 RSA-FDH-VRF Proving">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 RSA-FDH-VRF Proof To Hash">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 RSA-FDH-VRF Verifying">
<link href="#rfc.section.5" rel="Chapter" title="5 Elliptic Curve VRF (ECVRF)">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 ECVRF Proving">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 ECVRF Proof To Hash">
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 ECVRF Verifying">
<link href="#rfc.section.5.4" rel="Chapter" title="5.4 ECVRF Auxiliary Functions">
<link href="#rfc.section.5.4.1" rel="Chapter" title="5.4.1 ECVRF Hash To Curve">
<link href="#rfc.section.5.4.2" rel="Chapter" title="5.4.2 ECVRF Nonce Generation">
<link href="#rfc.section.5.4.3" rel="Chapter" title="5.4.3 ECVRF Hash Points">
<link href="#rfc.section.5.4.4" rel="Chapter" title="5.4.4 ECVRF Decode Proof">
<link href="#rfc.section.5.5" rel="Chapter" title="5.5 ECVRF Ciphersuites">
<link href="#rfc.section.5.6" rel="Chapter" title="5.6 When the ECVRF Keys are Untrusted">
<link href="#rfc.section.5.6.1" rel="Chapter" title="5.6.1 ECVRF Validate Key">
<link href="#rfc.section.6" rel="Chapter" title="6 Implementation Status">
<link href="#rfc.section.7" rel="Chapter" title="7 Security Considerations">
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Key Generation">
<link href="#rfc.section.7.1.1" rel="Chapter" title="7.1.1 Uniqueness and collision resistance with untrusted keys">
<link href="#rfc.section.7.1.2" rel="Chapter" title="7.1.2 Pseudorandomness with untrusted keys">
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Selective vs Full Pseudorandomness">
<link href="#rfc.section.7.3" rel="Chapter" title="7.3 Proper pseudorandom nonce for ECVRF">
<link href="#rfc.section.7.4" rel="Chapter" title="7.4 Side-channel attacks">
<link href="#rfc.section.7.5" rel="Chapter" title="7.5 Proofs Provide No Secrecy for VRF Input">
<link href="#rfc.section.7.6" rel="Chapter" title="7.6 Prehashing">
<link href="#rfc.section.7.7" rel="Chapter" title="7.7 Hash function domain separation and future-proofing">
<link href="#rfc.section.8" rel="Chapter" title="8 Change Log">
<link href="#rfc.section.9" rel="Chapter" title="9 Contributors">
<link href="#rfc.references" rel="Chapter" title="10 References">
<link href="#rfc.references.1" rel="Chapter" title="10.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="10.2 Informative References">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.9.8 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Goldberg, S., Reyzin, L., Papadopoulos, D., and J. Vcelak" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-irtf-cfrg-vrf-03" />
  <meta name="dct.issued" scheme="ISO8601" content="2018-31" />
  <meta name="dct.abstract" content="A Verifiable Random Function (VRF) is the public-key version of a keyed cryptographic hash. Only the holder of the private key can compute the hash, but anyone with public key can verify the correctness of the hash.  VRFs are useful for preventing enumeration of hash-based data structures.  This document specifies several VRF constructions that are secure in the cryptographic random oracle model. One  VRF uses RSA and the other VRF uses Eliptic Curves (EC).  " />
  <meta name="description" content="A Verifiable Random Function (VRF) is the public-key version of a keyed cryptographic hash. Only the holder of the private key can compute the hash, but anyone with public key can verify the correctness of the hash.  VRFs are useful for preventing enumeration of hash-based data structures.  This document specifies several VRF constructions that are secure in the cryptographic random oracle model. One  VRF uses RSA and the other VRF uses Eliptic Curves (EC).  " />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">CFRG</td>
<td class="right">S. Goldberg</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">L. Reyzin</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">Boston University</td>
</tr>
<tr>
<td class="left">Expires: March 4, 2019</td>
<td class="right">D. Papadopoulos</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Hong Kong University of Science and Techology</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">J. Vcelak</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">NS1</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">August 31, 2018</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Verifiable Random Functions (VRFs)<br />
  <span class="filename">draft-irtf-cfrg-vrf-03</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>A Verifiable Random Function (VRF) is the public-key version of a keyed cryptographic hash. Only the holder of the private key can compute the hash, but anyone with public key can verify the correctness of the hash.  VRFs are useful for preventing enumeration of hash-based data structures.  This document specifies several VRF constructions that are secure in the cryptographic random oracle model. One  VRF uses RSA and the other VRF uses Eliptic Curves (EC).  </p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on March 4, 2019.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2018 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Rationale</a>
</li>
<li>1.2.   <a href="#rfc.section.1.2">Requirements</a>
</li>
<li>1.3.   <a href="#rfc.section.1.3">Terminology</a>
</li>
</ul><li>2.   <a href="#rfc.section.2">VRF Algorithms</a>
</li>
<li>3.   <a href="#rfc.section.3">VRF Security Properties</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Full Uniqueness or Trusted Uniqueness</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">Full Collison Resistance or Trusted Collision Resistance</a>
</li>
<li>3.3.   <a href="#rfc.section.3.3">Full Pseudorandomness or Selective Pseudorandomness</a>
</li>
<li>3.4.   <a href="#rfc.section.3.4">A random-oracle-like unpredictability property</a>
</li>
</ul><li>4.   <a href="#rfc.section.4">RSA Full Domain Hash VRF (RSA-FDH-VRF)</a>
</li>
<ul><li>4.1.   <a href="#rfc.section.4.1">RSA-FDH-VRF Proving</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">RSA-FDH-VRF Proof To Hash</a>
</li>
<li>4.3.   <a href="#rfc.section.4.3">RSA-FDH-VRF Verifying</a>
</li>
</ul><li>5.   <a href="#rfc.section.5">Elliptic Curve VRF (ECVRF)</a>
</li>
<ul><li>5.1.   <a href="#rfc.section.5.1">ECVRF Proving</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">ECVRF Proof To Hash</a>
</li>
<li>5.3.   <a href="#rfc.section.5.3">ECVRF Verifying</a>
</li>
<li>5.4.   <a href="#rfc.section.5.4">ECVRF Auxiliary Functions</a>
</li>
<ul><li>5.4.1.   <a href="#rfc.section.5.4.1">ECVRF Hash To Curve</a>
</li>
<li>5.4.2.   <a href="#rfc.section.5.4.2">ECVRF Nonce Generation</a>
</li>
<li>5.4.3.   <a href="#rfc.section.5.4.3">ECVRF Hash Points</a>
</li>
<li>5.4.4.   <a href="#rfc.section.5.4.4">ECVRF Decode Proof</a>
</li>
</ul><li>5.5.   <a href="#rfc.section.5.5">ECVRF Ciphersuites</a>
</li>
<li>5.6.   <a href="#rfc.section.5.6">When the ECVRF Keys are Untrusted</a>
</li>
<ul><li>5.6.1.   <a href="#rfc.section.5.6.1">ECVRF Validate Key</a>
</li>
</ul></ul><li>6.   <a href="#rfc.section.6">Implementation Status</a>
</li>
<li>7.   <a href="#rfc.section.7">Security Considerations</a>
</li>
<ul><li>7.1.   <a href="#rfc.section.7.1">Key Generation</a>
</li>
<ul><li>7.1.1.   <a href="#rfc.section.7.1.1">Uniqueness and collision resistance with untrusted keys</a>
</li>
<li>7.1.2.   <a href="#rfc.section.7.1.2">Pseudorandomness with untrusted keys</a>
</li>
</ul><li>7.2.   <a href="#rfc.section.7.2">Selective vs Full Pseudorandomness</a>
</li>
<li>7.3.   <a href="#rfc.section.7.3">Proper pseudorandom nonce for ECVRF</a>
</li>
<li>7.4.   <a href="#rfc.section.7.4">Side-channel attacks</a>
</li>
<li>7.5.   <a href="#rfc.section.7.5">Proofs Provide No Secrecy for VRF Input</a>
</li>
<li>7.6.   <a href="#rfc.section.7.6">Prehashing</a>
</li>
<li>7.7.   <a href="#rfc.section.7.7">Hash function domain separation and future-proofing</a>
</li>
</ul><li>8.   <a href="#rfc.section.8">Change Log</a>
</li>
<li>9.   <a href="#rfc.section.9">Contributors</a>
</li>
<li>10.   <a href="#rfc.references">References</a>
</li>
<ul><li>10.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>10.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#intro" id="intro">Introduction</a>
</h1>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> Rationale</h1>
<p id="rfc.section.1.1.p.1">A Verifiable Random Function (VRF) <a href="#MRV99" class="xref">[MRV99]</a> is the public-key version of a keyed cryptographic hash. Only the holder of the private VRF key can compute the hash, but anyone with corresponding public key can verify the correctness of the hash.  </p>
<p id="rfc.section.1.1.p.2">A key application of the VRF is to provide privacy against offline enumeration (e.g. dictionary attacks) on data  stored in a hash-based data structure.  In this application, a Prover holds the VRF private key and uses the VRF hashing to construct a hash-based data structure on the input data.  Due to the nature of the VRF, only the Prover can answer queries about whether or not some data is stored in the data structure.  Anyone who knows the public VRF key can verify that the Prover has answered the queries correctly. However no offline inferences (i.e. inferences without querying the Prover) can be made about the data stored in the data strucuture.  </p>
<h1 id="rfc.section.1.2">
<a href="#rfc.section.1.2">1.2.</a> Requirements</h1>
<p id="rfc.section.1.2.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119" class="xref">[RFC2119]</a>.  </p>
<h1 id="rfc.section.1.3">
<a href="#rfc.section.1.3">1.3.</a> Terminology</h1>
<p id="rfc.section.1.3.p.1">The following terminology is used through this document: </p>
<p></p>

<dl>
<dt>SK:</dt>
<dd style="margin-left: 8">The private key for the VRF.  </dd>
<dt>PK:</dt>
<dd style="margin-left: 8">The public key for the VRF.  </dd>
<dt>alpha or alpha_string:</dt>
<dd style="margin-left: 8">The input to be hashed by the VRF.  </dd>
<dt>beta or beta_string:</dt>
<dd style="margin-left: 8">The VRF hash output.  </dd>
<dt>pi or pi_string:</dt>
<dd style="margin-left: 8">The VRF proof.  </dd>
<dt>Prover:</dt>
<dd style="margin-left: 8">The Prover holds the private VRF key SK and public VRF key PK.  </dd>
<dt>Verifier:</dt>
<dd style="margin-left: 8">The Verifier holds the public VRF key PK.  </dd>
</dl>

<p> </p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> VRF Algorithms</h1>
<p id="rfc.section.2.p.1">A VRF comes with a key generation algorithm that generates a public VRF key PK and private VRF key SK.  </p>
<p id="rfc.section.2.p.2">The prover hashes an input alpha using the private VRF key SK to obtain a VRF hash output beta </p>

<ul class="empty"><li>beta = VRF_hash(SK, alpha) </li></ul>

<p> The VRF_hash algorithm is deterministic, in the sense that it always produces the same output beta given a pair of inputs (SK, alpha).  The prover also uses the private key SK to construct a proof pi that beta is the correct hash output </p>

<ul class="empty"><li>pi = VRF_prove(SK, alpha)</li></ul>

<p> The VRFs defined in this document allow anyone to deterministically obtain the VRF hash output beta directly from the proof value pi as </p>

<ul class="empty"><li>beta = VRF_proof_to_hash(pi)</li></ul>

<p> Notice that this means that </p>

<ul class="empty"><li>VRF_hash(SK, alpha) = VRF_proof_to_hash(VRF_prove(SK, alpha))</li></ul>

<p> and thus this document will specify VRF_prove and VRF_proof_to_hash rather than VRF_hash.  </p>
<p id="rfc.section.2.p.3">The proof pi allows a Verifier holding the public key PK to verify that beta is the correct VRF hash of input alpha under key PK. Thus, the VRF also comes with an algorithm </p>

<ul class="empty"><li>VRF_verify(PK, alpha, pi)</li></ul>

<p> that outputs VALID if pi was correctly produced, and outputs INVALID otherwise. [TODO: should we force proof_to_hash to run verify first in our spec, to prevent possible mistakes?] </p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#secdef" id="secdef">VRF Security Properties</a>
</h1>
<p id="rfc.section.3.p.1">VRFs are designed to ensure the following security properties.  </p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> Full Uniqueness or Trusted Uniqueness</h1>
<p id="rfc.section.3.1.p.1">Uniqueness means that, for any fixed public VRF key and for any input alpha, there is a unique VRF output beta that can be proved to be valid.  Uniqueness must hold even for an adversarial Prover that knows the VRF private key SK.  </p>
<p id="rfc.section.3.1.p.2">More precisely, "full uniqueness" states that a computationally-bounded adversary cannot choose a VRF public key PK, a VRF input alpha, and two proofs pi1 and pi2 such that VRF_verify(PK, alpha, pi1) and VRF_verify(PK, alpha, pi2) both output VALID, and VRF_proof_to_hash(pi1) is not equal to VRF_proof_to_hash(pi2).  </p>
<p id="rfc.section.3.1.p.3">A slightly weaker security property called "trusted uniqueness" sufficies for many applications.  Trusted uniqueness is the same as full uniqueness, but it must hold only if the VRF keys PK and SK were generated in a trustworthy manner. In other words, uniqueness might not hold if keys were generated in an invalid manner or with bad randomness.  </p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> Full Collison Resistance or Trusted Collision Resistance</h1>
<p id="rfc.section.3.2.p.1">Like any cryprographic hash function, VRFs need to be collision resistant.  Collison resistance must hold even for an adversarial Prover that knows the VRF private key SK.  </p>
<p id="rfc.section.3.2.p.2">More precisely, "full collision resistance" states that it should be computationally infeasible for an adversary to find two distinct VRF inputs alpha1 and alpha2 that have the same VRF hash beta, even if that adversary knows the private VRF key SK.  </p>
<p id="rfc.section.3.2.p.3">For most applications, a slightly weaker security property called "trusted collision resistance" suffices.  Trusted collision resistance is the same as collision resistance, but it holds only if PK and SK were generated in a trustworthy manner.  </p>
<h1 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> <a href="#pseudodef" id="pseudodef">Full Pseudorandomness or Selective Pseudorandomness</a>
</h1>
<p id="rfc.section.3.3.p.1">Pseudorandomness ensures that when an adversarial Verifier sees a VRF hash output beta without its corresponding VRF proof pi, then beta is indistinguishable from a random value.  </p>
<p id="rfc.section.3.3.p.2">More precisely, suppose the public and private VRF keys (PK, SK) were generated in a trustworthy manner.  Pseudorandomness ensures that the VRF hash output beta (without its corresponding VRF proof pi) on any adversarially-chosen "target" VRF input alpha looks indistinguishable from random for any computationally bounded adversary who does not know the private VRF key SK.  This holds even if the adversary also gets to choose other VRF inputs alpha' and observe their corresponding VRF hash outputs beta' and proofs pi'.  </p>
<p id="rfc.section.3.3.p.3">With "full pseudorandomness", the adversary is allowed to choose the "target" VRF input  alpha at any time, even after it observes VRF outputs beta' and proofs pi' on a variety of chosen inputs alpha'.  </p>
<p id="rfc.section.3.3.p.4">"Selective pseudorandomness" is a weaker security property which suffices in many applications. Here, the adversary must choose the target VRF input alpha independently of the public VRF key PK, and before it  observes VRF outputs beta' and proofs pi' on inputs alpha' of its choice.  </p>
<p id="rfc.section.3.3.p.5">It is important to remember that the VRF output beta does not look random to the Prover, or to any other party that knows the private VRF key SK!  Such a party can easily distinguish beta from a random value by comparing beta to the result of VRF_hash(SK, alpha).  </p>
<p id="rfc.section.3.3.p.6">Also, the VRF output beta does not look random to any party that knows valid VRF proof pi corresponding to the VRF input alpha, even if this party does not know the private VRF key SK.  Such a party can easily distinguish beta from a random value by checking whether VRF_verify(PK, alpha, pi) returns "VALID" and beta = VRF_proof_to_hash(pi).  </p>
<p id="rfc.section.3.3.p.7">Also, the VRF output beta may not look random if VRF key generation was not done in a trustworthy fashion. (For example, if VRF keys were generated with bad randomness.) </p>
<h1 id="rfc.section.3.4">
<a href="#rfc.section.3.4">3.4.</a> A random-oracle-like unpredictability property</h1>
<p id="rfc.section.3.4.p.1">[TODO:   This property is not needed for applications that use VRFs to prevent enumeration of hash-based data structures.  However, we noticed that some other applications of VRF (e.g. Algorand, Oroborus) rely on this property.  We are waiting on a formal definition of this property in the literature, and a proof that our ECVRF scheme can satisfy this property.  Preliminary analysis suggests that acheiving this property requires ECVRF verifiers to run an VRF_validate_key() key function upon receipt of VRF public keys and the proof_to_hash function to be modified to take in (Gamma, beta, pk) rather than just Gamma.]</p>
<p id="rfc.section.3.4.p.2">Pseudorandomness, as defined in <a href="#pseudodef" class="xref">Section 3.3</a>, does not hold if the VRF keys were generated adversarially. For instance, if an adversary outputs VRF keys that are deterministically generated (or hard-coded and publicly known), then the outputs are easily derived by anyone.  </p>
<p id="rfc.section.3.4.p.3">There is, however, a different type of unpredictability that could hold even if the VRF keys are generated adversarially, as long as the VRF input alpha is unpredictable.  This property is similar to the unpredictability achieved by an (ordinary, unkeyed) cryptographic hash function: if the input has enough entropy (i.e., cannot be predicted), then the output is indistinguishable from uniform.  </p>
<p id="rfc.section.3.4.p.4">The ECVRF scheme presented in this specification satisfies this property if the public key satisfies the key validation procedure in <a href="#keycheck" class="xref">Section 5.6</a>.</p>
<p id="rfc.section.3.4.p.5">[TODO: edit further or decide to leave this alone.] </p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#fdh" id="fdh">RSA Full Domain Hash VRF (RSA-FDH-VRF)</a>
</h1>
<p id="rfc.section.4.p.1">The RSA Full Domain Hash  VRF (RSA-FDH-VRF) is a VRF that satisfies the "trusted uniqueness", "trusted collision resistance", and "full pseudorandomness" properties defined in <a href="#secdef" class="xref">Section 3</a>.  Its security follows from the standard RSA assumption in the random oracle model.  Formal security proofs are in <a href="#nsec5ecc" class="xref">[nsec5ecc]</a>.  </p>
<p id="rfc.section.4.p.2">The VRF computes the proof pi as a deterministic RSA signature on input alpha using the RSA Full Domain Hash Algorithm <a href="#RFC8017" class="xref">[RFC8017]</a> parametrized with the selected hash algorithm.  RSA signature verification is used to verify the correctness of the proof. The VRF hash output beta is simply obtained by hashing the proof pi with the selected hash algorithm.  </p>
<p id="rfc.section.4.p.3">The key pair for RSA-FDH-VRF MUST be generated in a way that it satisfies the conditions specified in Section 3 of <a href="#RFC8017" class="xref">[RFC8017]</a>.  </p>
<p id="rfc.section.4.p.4">In this document, the notation from <a href="#RFC8017" class="xref">[RFC8017]</a> is used.  </p>
<p id="rfc.section.4.p.5">Parameters used: </p>

<ul class="empty">
<li>(n, e) - RSA public key</li>
<li>K - RSA private key</li>
<li>k - length in octets of the RSA modulus n (k must be less than 2^32)</li>
</ul>

<p> </p>
<p id="rfc.section.4.p.6">Fixed options: </p>

<ul class="empty">
<li>Hash - cryptographic hash function</li>
<li>hLen - output length in octets of hash function Hash</li>
</ul>

<p> </p>
<p id="rfc.section.4.p.7">Primitives used: </p>

<ul class="empty">
<li>I2OSP - Conversion of a nonnegative integer to an octet string as defined in Section 4.1 of <a href="#RFC8017" class="xref">[RFC8017]</a> </li>
<li>OS2IP - Conversion of an octet string to a nonnegative integer as defined in Section 4.2 of <a href="#RFC8017" class="xref">[RFC8017]</a> </li>
<li>RSASP1 - RSA signature primitive as defined in Section 5.2.1 of <a href="#RFC8017" class="xref">[RFC8017]</a> </li>
<li>RSAVP1 - RSA verification primitive as defined in Section 5.2.2 of <a href="#RFC8017" class="xref">[RFC8017]</a> </li>
<li>MGF1 - Mask Generation Function based on the hash function Hash as defined in Section B.2.1 of <a href="#RFC8017" class="xref">[RFC8017]</a> </li>
<li>|| - octet string concatenation </li>
</ul>

<p> </p>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> RSA-FDH-VRF Proving</h1>
<p id="rfc.section.4.1.p.1">RSAFDHVRF_prove(K, alpha_string) </p>
<p id="rfc.section.4.1.p.2">Input: </p>

<ul class="empty">
<li>K - RSA private key</li>
<li>alpha_string - VRF hash input, an octet string</li>
</ul>

<p> </p>
<p id="rfc.section.4.1.p.3">Output: </p>

<ul class="empty"><li>pi_string - proof, an octet string of length k</li></ul>

<p> </p>
<p id="rfc.section.4.1.p.4">Steps: </p>

<ol>
<li>one_string = 0x01 = I2OSP(1, 1), a single octet with value 1</li>
<li>EM = MGF1(one_string || I2OSP(k, 4) || I2OSP(n, k) ||  alpha_string, k - 1)</li>
<li>m = OS2IP(EM)</li>
<li>s = RSASP1(K, m)</li>
<li>pi_string = I2OSP(s, k)</li>
<li>Output pi_string</li>
</ol>

<p> </p>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> RSA-FDH-VRF Proof To Hash</h1>
<p id="rfc.section.4.2.p.1">RSAFDHVRF_proof_to_hash(pi_string) </p>
<p id="rfc.section.4.2.p.2">Input: </p>

<ul class="empty"><li>pi_string - proof, an octet string of length k</li></ul>

<p> </p>
<p id="rfc.section.4.2.p.3">Output: </p>

<ul class="empty"><li>beta_string - VRF hash output, an octet string of length hLen</li></ul>

<p> </p>
<p id="rfc.section.4.2.p.4">Steps: </p>

<ol>
<li>two_string = 0x02 = I2OSP(2, 1), a single octet with value 2</li>
<li>beta_string = Hash(two_string || pi_string)</li>
<li>Output beta_string</li>
</ol>

<p> </p>
<h1 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> RSA-FDH-VRF Verifying</h1>
<p id="rfc.section.4.3.p.1">RSAFDHVRF_verify((n, e), alpha_string, pi_string) </p>
<p id="rfc.section.4.3.p.2">Input: </p>

<ul class="empty">
<li>(n, e) - RSA public key</li>
<li>alpha_string - VRF hash input, an octet string</li>
<li>pi_string - proof to be verified, an octet string of length n</li>
</ul>

<p> </p>
<p id="rfc.section.4.3.p.3">Output: </p>

<ul class="empty"><li>"VALID" or "INVALID"</li></ul>

<p> </p>
<p id="rfc.section.4.3.p.4">Steps: </p>

<ol>
<li>s = OS2IP(pi_string)</li>
<li>m = RSAVP1((n, e), s)</li>
<li>EM = I2OSP(m, k - 1)</li>
<li>one_string = 0x01 = I2OSP(1, 1), a single octet with value 1</li>
<li>EM' = MGF1(one_string || I2OSP(k, 4) || I2OSP(n, k) ||  alpha_string, k - 1)</li>
<li>If EM and EM' are equal, output "VALID"; else output "INVALID".  </li>
</ol>

<p> </p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#ecvrf" id="ecvrf">Elliptic Curve VRF (ECVRF)</a>
</h1>
<p id="rfc.section.5.p.1">The Elliptic Curve Verifiable Random Function (ECVRF) is a VRF that satisfies the trusted uniqueness, trusted collision resistance, and full pseudorandomness properties defined in <a href="#secdef" class="xref">Section 3</a>.  The security of this VRF follows from the decisional Diffie-Hellman (DDH) assumption in the random oracle model. Formal security proofs are in <a href="#nsec5ecc" class="xref">[nsec5ecc]</a>.  </p>
<p id="rfc.section.5.p.2">To additionally satisfy "full uniqueness" and "full collision resistance", the Verifier MUST additionally perform the validation procedure specified in <a href="#keycheck" class="xref">Section 5.6</a>  upon receipt of the public VRF key.  </p>
<p id="rfc.section.5.p.3">Fixed options (specified in <a href="#suites" class="xref">Section 5.5</a>): </p>

<ul class="empty">
<li>F - finite field</li>
<li>2n - length, in octets, of a field element in F, rounded up to the nearest even integer</li>
<li>E - elliptic curve (EC) defined over F</li>
<li>m - length, in octets, of an EC point encoded as an octet string</li>
<li>G - subgroup of E of large prime order</li>
<li>q - prime order of group G; must be less than 2^{16n} [TODO: why limit it so? It could be one octet longer -- e.g., curve 192. Maybe introduce qLen.]</li>
<li>cofactor - number of points on E divided by q</li>
<li>B - generator of group G</li>
<li>Hash - cryptographic hash function</li>
<li>hLen - output length in octets of Hash; must be at least 2n</li>
<li>suite_string - a single nonzero octet specifying the ECVRF ciphersuite, which determines the above options</li>
</ul>

<p> </p>
<p id="rfc.section.5.p.4">Notation and primitives used [TODO: add explanation of additive EC notation and scalar multiplication]: </p>

<ul class="empty">
<li>a^b - exponentiation </li>
<li>|| - octet string concatenation</li>
<li>ECVRF_hash_to_curve - collision resistant hash of strings to an EC point; options described in <a href="#ecvrfH2C" class="xref">Section 5.4.1</a> and specified in <a href="#suites" class="xref">Section 5.5</a>.</li>
<li>ECVRF_nonce_generation - derives a pseudorandom nonce from SK and the input as part of ECVRF proving.  Specified in <a href="#suites" class="xref">Section 5.5</a>
</li>
<li>ECVRF_hash_points - collision resistant hash of EC points to an integer. Specified in <a href="#ecvrfHashPoints" class="xref">Section 5.4.3</a>.</li>
</ul>

<p> </p>
<p id="rfc.section.5.p.5">Type conversions: </p>

<ul class="empty">
<li>int_to_string(a, len) - conversion of nonnegative integer a to to octet string of length len as specified in <a href="#suites" class="xref">Section 5.5</a>.</li>
<li>string_to_int(a_string) - conversion of an octet string a_string to a nonnegative integer as specified in <a href="#suites" class="xref">Section 5.5</a>.</li>
<li>point_to_string - conversion of EC point to an m-octet string as specified in <a href="#suites" class="xref">Section 5.5</a>
</li>
<li>string_to_point - conversion of an m-octet string to EC point as specified in <a href="#suites" class="xref">Section 5.5</a>.  string_to_point returns INVALID if the octet string does not convert to a valid EC point.</li>
<li>arbitrary_string_to_point - conversion of an arbitrary 2n-octet string to an EC point as specified in <a href="#suites" class="xref">Section 5.5</a>
</li>
<li>Note that with certain software libraries (for big integer and elliptic curve arithmetic), the int_to_string and point_to_string conversions are not needed.  For example, in some implementations, EC point operations will take octet strings as inputs and produce octet strings as outputs, without introducing a seperate elliptic curve point type.) </li>
</ul>

<p> </p>
<p id="rfc.section.5.p.6">Parameters used (the generation of these parameters is specified in <a href="#suites" class="xref">Section 5.5</a>): </p>

<ul class="empty">
<li>SK - VRF private key</li>
<li>x - VRF secret scalar, an integer <ul class="empty"><li>Note: depending on the ciphersuite used, the VRF secret scalar may be equal to SK; else, it is derived from SK </li></ul>
<p> </p>
</li>
<li>Y = x*B - VRF public key, an EC point</li>
</ul>

<p> </p>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#ecvrfprove" id="ecvrfprove">ECVRF Proving</a>
</h1>
<p id="rfc.section.5.1.p.1">Note: this function must have the VRF private key SK as input.  Below we make it more efficient by supplying it also with the secret scalar x and the public key Y as additional inputs; however, each of these can be computed from SK if desired.  </p>
<p id="rfc.section.5.1.p.2">ECVRF_prove(Y, x, alpha_string) </p>
<p id="rfc.section.5.1.p.3">Input: </p>

<ul class="empty">
<li>SK - VRF private key</li>
<li>x - VRF secret scalar</li>
<li>Y = x*B - VRF public key</li>
<li>alpha_string = input alpha, an octet string</li>
</ul>

<p> </p>
<p id="rfc.section.5.1.p.4">Output: </p>

<ul class="empty"><li>pi_string - VRF proof, octet string of length m+3n</li></ul>

<p> </p>
<p id="rfc.section.5.1.p.5">Steps: </p>

<ol>
<li>H = ECVRF_hash_to_curve(suite_string, Y, alpha_string)</li>
<li>h_string = point_to_string(H)</li>
<li>Gamma = x*H</li>
<li>k = ECVRF_nonce_generation(SK, h_string)</li>
<li>c = ECVRF_hash_points(H, Gamma, k*B, k*H)</li>
<li>s = (k + c*x) mod q</li>
<li>pi_string = point_to_string(Gamma) || int_to_string(c, n) || int_to_string(s, 2n)</li>
<li>Output pi_string</li>
</ol>

<p> </p>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> ECVRF Proof To Hash</h1>
<p id="rfc.section.5.2.p.1">ECVRF_proof_to_hash(pi_string) </p>
<p id="rfc.section.5.2.p.2">Input: </p>

<ul class="empty"><li>pi_string - VRF proof, octet string of length m+3n</li></ul>

<p> </p>
<p id="rfc.section.5.2.p.3">Output: </p>

<ul class="empty">
<li>"INVALID", or </li>
<li>beta_string - VRF hash output, octet string of length 2n</li>
</ul>

<p> </p>
<p id="rfc.section.5.2.p.4">Steps: </p>

<ol>
<li>D = ECVRF_decode_proof(pi_string)</li>
<li>If D is "INVALID", output "INVALID" and stop</li>
<li>(Gamma, c, s) = D</li>
<li>three_string = 0x03 = int_to_string(3, 1), a single octet with value 3 </li>
<li>b_string = Hash(suite_string || three_string || point_to_string(cofactor * Gamma))</li>
<li>beta_string = b_string[0]...b_string[2n-1] [TODO: Is truncating the right thing to do? What if you want all 512 bits?] </li>
<li>Output beta_string</li>
</ol>

<p> </p>
<h1 id="rfc.section.5.3">
<a href="#rfc.section.5.3">5.3.</a> ECVRF Verifying</h1>
<p id="rfc.section.5.3.p.1">ECVRF_verify(Y, pi_string, alpha_string) </p>
<p id="rfc.section.5.3.p.2">Input: </p>

<ul class="empty">
<li>Y -  public key, an EC point</li>
<li>pi_string - VRF proof, octet string of length m+3n</li>
<li>alpha_string - VRF input, octet string</li>
</ul>

<p> </p>
<p id="rfc.section.5.3.p.3">Output: </p>

<ul class="empty"><li>"VALID" or "INVALID"</li></ul>

<p> </p>
<p id="rfc.section.5.3.p.4">Steps: </p>

<ol>
<li>D = ECVRF_decode_proof(pi_string)</li>
<li>If D is "INVALID", output "INVALID" and stop</li>
<li>(Gamma, c, s) = D</li>
<li>H = ECVRF_hash_to_curve(suite_string, Y, alpha_string)</li>
<li>U = s*B - c*Y</li>
<li>V = s*H - c*Gamma</li>
<li>c' = ECVRF_hash_points(H, Gamma, U, V)</li>
<li>If c and c' are equal, output "VALID"; else output "INVALID" </li>
</ol>

<p> </p>
<h1 id="rfc.section.5.4">
<a href="#rfc.section.5.4">5.4.</a> ECVRF Auxiliary Functions</h1>
<h1 id="rfc.section.5.4.1">
<a href="#rfc.section.5.4.1">5.4.1.</a> <a href="#ecvrfH2C" id="ecvrfH2C">ECVRF Hash To Curve</a>
</h1>
<p id="rfc.section.5.4.1.p.1">The ECVRF_hash_to_curve algorithm takes in the VRF input alpha and converts it to H, an EC point in G.  This algorithm is the only place the VRF input alpha is used in for proving and verfying. See <a href="#prehash" class="xref">Section 7.6</a> for further discussion.  </p>
<p id="rfc.section.5.4.1.p.2">The algorithms in this section are not compatible with each other; the choice of algorithm is made in <a href="#suites" class="xref">Section 5.5</a>.</p>
<h1 id="rfc.section.5.4.1.1">
<a href="#rfc.section.5.4.1.1">5.4.1.1.</a> <a href="#ecvrfH2C1" id="ecvrfH2C1">ECVRF_hash_to_curve_try_and_increment</a>
</h1>
<p id="rfc.section.5.4.1.1.p.1">The following ECVRF_hash_to_curve_try_and_increment(suite_string, Y, alpha_string) algorithm implements ECVRF_hash_to_curve in a simple and generic way that works for any elliptic curve.  </p>
<p id="rfc.section.5.4.1.1.p.2">The running time of this algorithm depends on alpha_string.  For the ciphersuites specified in <a href="#suites" class="xref">Section 5.5</a>, this algorithm is expected to find a valid curve point after approximately two attempts (i.e., when ctr=1) on average. See also <a href="#Icart09" class="xref">[Icart09]</a>. [TODO: do we need this reference?] </p>
<p id="rfc.section.5.4.1.1.p.3">However, because the running time of algorithm depends on alpha_string, this algorithm SHOULD be avoided in applications where it is important that the VRF input alpha remain secret.  </p>
<p id="rfc.section.5.4.1.1.p.4">ECVRF_hash_to_try_and_increment(suite_string, Y, alpha_string) </p>
<p id="rfc.section.5.4.1.1.p.5">Input: </p>

<ul class="empty">
<li>suite_string - a single octet specifying ECVRF ciphersuite. </li>
<li>Y - public key, an EC point</li>
<li>alpha_string - value to be hashed, an octet string</li>
</ul>

<p> </p>
<p id="rfc.section.5.4.1.1.p.6">Output: </p>

<ul class="empty"><li>H - hashed value, a finite EC point in G </li></ul>

<p> </p>
<p id="rfc.section.5.4.1.1.p.7">Steps: </p>

<ol>
<li>ctr = 0</li>
<li>PK_string = point_to_string(Y)</li>
<li>one_string = 0x01 = int_to_string(1, 1), a single octet with value 1 </li>
<li>H = "INVALID"</li>
<li>While H is "INVALID" or H is EC point at infinity: <ol style="list-style-type: upper-alpha">
<li>ctr_string = int_to_string(ctr, 4) [TODO: why 4 bytes? 1 is plenty. 1 is better because no big-endian/little-endian confusion and bug possibility (this counter will not a bigint, so actual programmers will have to do conversions differently for it)]</li>
<li>ctr = ctr + 1</li>
<li>hash_string = Hash(suite_string || one_string || PK_string || alpha_string || ctr_string)</li>
<li>attempted_hash_string = hash_string[0]...hash_string[2n-1] </li>
<li>H = arbitrary_string_to_point(attempted_hash_string)</li>
<li>If H is not "INVALID" and cofactor &gt; 1, set H = cofactor * H</li>
</ol>
</li>
<li>Output H</li>
</ol>

<p> </p>
<h1 id="rfc.section.5.4.1.2">
<a href="#rfc.section.5.4.1.2">5.4.1.2.</a> <a href="#elligator2" id="elligator2">ECVRF_hash_to_curve_elligator2_25519</a>
</h1>
<p id="rfc.section.5.4.1.2.p.1">The following ECVRF_hash_to_curve_elligator2_25519(suite_string, Y, alpha_string) algorithm implements ECVRF_hash_to_curve using the elligator2 algorithm exclusively for the Ed25519 elliptic curve (which the Edwards equivalent of Curve25519).  </p>
<p id="rfc.section.5.4.1.2.p.2">ECVRF_hash_to_curve_elligator2_25519(suite_string, Y, alpha_string) </p>
<p id="rfc.section.5.4.1.2.p.3">Input: </p>

<ul class="empty">
<li>suite_string - a single octet specifying ECVRF ciphersuite. </li>
<li>alpha_string - value to be hashed, an octet string</li>
<li>Y - public key, an EC point</li>
</ul>

<p> </p>
<p id="rfc.section.5.4.1.2.p.4">Output: </p>

<ul class="empty"><li>H - hashed value, a finite EC point in G </li></ul>

<p> </p>
<p id="rfc.section.5.4.1.2.p.5">Fixed options: </p>

<ul class="empty">
<li>p = 2^255-19, the size of the finite field F, a prime, for Curve25519</li>
<li>A = 486662, Montgomery curve constant for Curve25519 </li>
<li>cofactor = 8 , the cofactor for Curve25519 </li>
</ul>

<p> </p>
<p id="rfc.section.5.4.1.2.p.6">Constraints on options: </p>

<ul class="empty"><li>output length of Hash is at least 16n (i.e., 256) bits</li></ul>

<p> </p>
<p id="rfc.section.5.4.1.2.p.7">Steps: </p>

<ol>
<li>PK_string = point_to_string(Y)</li>
<li>one_string = 0x01 = int_to_string(1, 1) <br>(a single octet with value 1) </li>
<li>hash_string = Hash(suite_string || one_string || PK_string || alpha_string )</li>
<li>truncated_h_string = hash_string[0]...hash_string[31] </li>
<li>oneTwentyEight_string = 0x80 = int_to_string(128, 1) <br>(a single octet with value 128)</li>
<li>oneTwentySeven_string = 0x7F = int_to_string(127, 1) <br>(a single octet with value 127)</li>
<li>x0 = truncated_h_string[31] &amp; oneTwentyEight_string <br>(where &amp; denotes the bit-wise AND) <br>(this step saves highest-order bit of octet 31 in x0)</li>
<li>truncated_h_string[31] = truncated_h_string[31] &amp; oneTwentySeven_string <br>(this step clears the high-order bit of octet 31)</li>
<li>r = string_to_int(truncated_h_string)</li>
<li>u = - A / (1 + 2*(r^2) )  mod p <br>(note: the inverse of (1+2*(r^2)) modulo p is guaranteed to exist)</li>
<li>w = u * (u^2 + A*u + 1) mod p <br>(this step evaluates the Montgomery equation for Curve25519)</li>
<li>Let e equal the Legendre symbol of w and p <br>(see note below on how to compute e)</li>
<li>If e is equal to 1 then final_u = u; else final_u = (-A - u) mod p <br>(note: final_u is the Montgomery u-coordinate of the output; see note below on how to compute it)</li>
<li>y_coordinate = (final_u - 1) / (final_u + 1) mod p <br>(note 1: y_coordinate is the Edwards coordinate corresponding to final_u) <br>(note 2: the inverse of (final_u + 1) modulo p is guaranteed to exist)</li>
<li>Form an octet string encoding of an elliptic curve point out of y_coordinate and x0, as follows: <ol style="list-style-type: upper-alpha">
<li>h_string = int_to_string (y_coordinate, 32)</li>
<li>h_string[31] = h_string[31] | x0 [TODO: should we do this? hash-to-curve draft doesn't] <br>(where | denotes the bit-wise OR)</li>
</ol>
<p> </p>
</li>
<li>H = string_to_point(h_string) <br> (note: string_to_point will not return INVALID by correctness of Elligator2)</li>
<li>Set H = cofactor * H <br>[TODO: There is a tiny chance this operation will produce point at infinity. The chance is so tiny that it shouldn't be a problem and it's perfecty encodable (y_1 = 1, x = 0), but will it break some implementations and cause testing headaches for developers?]</li>
<li>Output H</li>
</ol>

<p> </p>
<p id="rfc.section.5.4.1.2.p.8">In order to make this algorithm run in time that is (almost) independent of the input alpha_string (so-called "constant-time"), implementers should pay particular attention to Steps 12 and 13 above.  These steps can be implemented using the following approach: </p>

<ul class="empty">
<li>e = w ^ ((p-1)/2) mod p</li>
<li>final_u = (e*u + (e-1) * (A/2)) mod p</li>
</ul>

<p> The first step will produce a value e that is either 1 or p-1 (it is guaranteed not to be any other value, because w is guaranteed to be nonzero). Implementers should also ensure that the second step runs in the same amount of time regardless of e by ensuring that arithmetic in constant time.  </p>
<p id="rfc.section.5.4.1.2.p.9">Alternatively, let CMOV(result_if_1, result_if_0, selector) be the function that returns result_if_1 when selector is 1 and  result_if_0 when selector is 0. If CMOV is implemented in constant time, then steps 12 and 13 above can be implemented as follows: </p>

<ul class="empty">
<li>e = (w^((p-1)/2))+1 mod p</li>
<li>b = e/2</li>
<li>other_u = (-A-u) mod p</li>
<li>final_u = CMOV(u, other_u, b)</li>
</ul>

<p> (Note that after the first step, e is either 0 or 2, and only the least significant byte of e is needed in the second step).  [TODO: Should we explain how to implement CMOV in constant time? ] [TODO: Do we have appropriate references to the literature where Elligator2 was proposed and to other standards?] </p>
<p id="rfc.section.5.4.1.2.p.10">If having this algorithm run in constant time is not important, then there are much faster algorithms to compute the Legendre symbol (which is the same as the Jacobi symbol because p is a prime).  See, for example, Section 12.3 of <a href="#ntb" class="xref">[ntb]</a>.  </p>
<h1 id="rfc.section.5.4.1.3">
<a href="#rfc.section.5.4.1.3">5.4.1.3.</a> <a href="#SimpleSWU" id="SimpleSWU">ECVRF_hash_to_curve_Simplified_SWU</a>
</h1>
<p id="rfc.section.5.4.1.3.p.1">The following ECVRF_hash_to_curve_Simplified_SWU(suite_string, Y, alpha_string) algorithm implements ECVRF_hash_to_curve using the simplified Shallue-Woestijne-Ulas algorithm from [TODO: add reference to <a href="#BCIMRT10" class="xref">[BCIMRT10]</a> and <a href="#SW18" class="xref">[SW18]</a>, latest version] for any curve with prime p that is congruent to 3 modulo 4.  </p>
<p id="rfc.section.5.4.1.3.p.2">ECVRF_hash_to_curve_Simplified_SWU(suite_string, Y, alpha_string) </p>
<p id="rfc.section.5.4.1.3.p.3">Input: </p>

<ul class="empty">
<li>suite_string - a single octet specifying ECVRF ciphersuite. </li>
<li>alpha_string - value to be hashed, an octet string</li>
<li>Y - public key, an EC point</li>
</ul>

<p> </p>
<p id="rfc.section.5.4.1.3.p.4">Output: </p>

<ul class="empty"><li>H - hashed value, a finite EC point in G </li></ul>

<p> </p>
<p id="rfc.section.5.4.1.3.p.5">Fixed options: </p>

<ul class="empty">
<li>a and b, constants for the Weierstrass form elliptic curve equation y^2 = x^3 + ax +b for the curve E</li>
<li>default_x, to be used in the negligbly likely case that this algorithm cannot compute an answer because of division by 0 [TODO: what should this be?]</li>
</ul>

<p> </p>
<p id="rfc.section.5.4.1.3.p.6">Steps: </p>

<ol>
<li>PK_string = EC2OSP(Y)</li>
<li>one_string = 0x01 = I2OSP(1, 1), a single octet with value 1 </li>
<li>h_string = Hash(suite_string || one_string || PK_string || alpha_string)</li>
<li>t = string_to_int(h_string)</li>
<li>r = -(t^2) mod p</li>
<li>d = (r^2 + r) mod p <br>(d is t^4-t^2 mod p)</li>
<li>If d = 0 then x = default_x; else x = ((-b/a) * (1 + (1/d))) mod p.</li>
<li>w = (x^3 + a*x + b) mod p <br>(this step evaluates the curve equation)</li>
<li>Let e equal the Legendre symbol of w and p <br>(see note below on how to compute e)</li>
<li>If e is equal to 0 or 1 then final_x = x; else final_x = r * x mod p <br>(final_x is the x-coordinate of the output; see note below on how to compute it)</li>
<li>H = arbitrary_string_to_point(int_to_string(final_x, 2n)) <br> (note: arbitrary_string_to_point will not return INVALID by correctness of Simple SWU)</li>
<li>If cofactor &gt; 1, set H = cofactor * H</li>
<li>Output H</li>
</ol>

<p> </p>
<p id="rfc.section.5.4.1.3.p.7">In order to make this algorithm run in time that is (almost) independent of the input (so-called "constant-time"), implementers should pay particular attention to Steps 9 and 10 above.  These steps can be implemented using the following approach.  Let CMOV(result_if_1, result_if_0, selector) be the function that returns result_if_1 when selector is 1 and  result_if_0 when selector is 0. If arithmetic and CMOV are implemented in constant time, then steps 9 and 10 above can be implemented as follows: </p>

<ul class="empty">
<li>e = (w ^ ((p-1)/2))+1 mod p <br>(At this point, e is 0, 1, or 2, as an integer.)</li>
<li>Let b = (e+1) / 2, where / denotes integer division with rounding down.  <br>(Note carefully that this step is integer, not modular, division. Only the last byte of e is needed for this step. This step converts 0, 1, or 2 to 0 or 1.)</li>
<li>other_x = r * x mod p</li>
<li>final_x = CMOV(x, other_x, b)</li>
</ul>

<p> [TODO: Should we explain how to implement CMOV in constant time?] </p>
<p id="rfc.section.5.4.1.3.p.8">If having this algorithm run in constant time is not important, then there are much faster algorithms to compute the Legendre symbol (which is the same as the Jacobi symbol because p is a prime).  See, for example, Section 12.3 of <a href="#ntb" class="xref">[ntb]</a>.  </p>
<h1 id="rfc.section.5.4.2">
<a href="#rfc.section.5.4.2">5.4.2.</a> <a href="#ecvrfNonceGeneration" id="ecvrfNonceGeneration">ECVRF Nonce Generation</a>
</h1>
<p id="rfc.section.5.4.2.p.1">The following subroutines generate the nonce value k in a deterministic pseudorandom fashion.</p>
<h1 id="rfc.section.5.4.2.1">
<a href="#rfc.section.5.4.2.1">5.4.2.1.</a> <a href="#nonceP256" id="nonceP256">ECVRF Nonce Generation From RFC 6979</a>
</h1>
<p id="rfc.section.5.4.2.1.p.1">ECVRF_nonce_generation_RFC6979(SK, h_string) </p>
<p id="rfc.section.5.4.2.1.p.2">Input: </p>

<ul class="empty">
<li>SK - an ECVRF secret key</li>
<li>h_string - an octet string</li>
</ul>

<p> </p>
<p id="rfc.section.5.4.2.1.p.3">Output: </p>

<ul class="empty"><li>k - an integer between 1 and q-1</li></ul>

<p> </p>
<p id="rfc.section.5.4.2.1.p.4">The ECVRF_nonce_generation function is as specified in <a href="#RFC6979" class="xref">[RFC6979]</a> Section 3.2 where </p>

<ul class="empty">
<li>Step a is omitted</li>
<li>h_1 is set equal to h_string</li>
<li>The "suitable for DSA or ECDSA" check in step h.3 is omitted</li>
<li>The hash function H is Hash and its output length hlen is set as hLen*8</li>
<li>The secret key x is set equal to the VRF secret scalar x </li>
<li>The prime q is the same as in this specification</li>
<li>All the other values and primitives as defined in <a href="#RFC6979" class="xref">[RFC6979]</a> </li>
</ul>

<p> </p>
<h1 id="rfc.section.5.4.2.2">
<a href="#rfc.section.5.4.2.2">5.4.2.2.</a> <a href="#nonce25519" id="nonce25519">ECVRF Nonce Generation From RFC 8032</a>
</h1>
<p id="rfc.section.5.4.2.2.p.1">The following is from Steps 2-3 of Section 5.1.6 in <a href="#RFC8032" class="xref">[RFC8032]</a>.  </p>
<p id="rfc.section.5.4.2.2.p.2">ECVRF_nonce_generation_RFC8032(SK, h_string) </p>
<p id="rfc.section.5.4.2.2.p.3">Input: </p>

<ul class="empty">
<li>SK - an ECVRF secret key</li>
<li>h_string - an octet string</li>
</ul>

<p> </p>
<p id="rfc.section.5.4.2.2.p.4">Output: </p>

<ul class="empty"><li>k - an integer between 0 and q-1</li></ul>

<p> </p>
<p id="rfc.section.5.4.2.2.p.5">Steps: </p>

<ol>
<li>hashed_sk_string = Hash (SK)</li>
<li>truncated_hashed_sk_string = hashed_sk_string[32]...hashed_sk_string[63]</li>
<li>k_string = Hash(truncated_hashed_sk_string || h_string)</li>
<li>k = string_to_int(k_string) mod q</li>
</ol>

<p> </p>
<h1 id="rfc.section.5.4.3">
<a href="#rfc.section.5.4.3">5.4.3.</a> <a href="#ecvrfHashPoints" id="ecvrfHashPoints">ECVRF Hash Points</a>
</h1>
<p id="rfc.section.5.4.3.p.1">ECVRF_hash_points(P1, P2, ..., PM) </p>
<p id="rfc.section.5.4.3.p.2">Input: </p>

<ul class="empty"><li>P1...PM - EC points in G</li></ul>

<p> </p>
<p id="rfc.section.5.4.3.p.3">Output: </p>

<ul class="empty"><li>c - hash value, integer between 0 and 2^(8n)-1</li></ul>

<p> </p>
<p id="rfc.section.5.4.3.p.4">Steps: </p>

<ol>
<li>two_string = 0x02 = int_to_string(2, 1), a single octet with value 2 </li>
<li>Initialize str = suite_string || two_string </li>
<li>for PJ in [P1, P2, ... PM]: <br>str = str || point_to_string(PJ) </li>
<li>c_string = Hash(str)</li>
<li>truncated_c_string = c_string[0]...c_string[n-1] </li>
<li>c = string_to_int(truncated_c_string)</li>
<li>Output c</li>
</ol>

<p> </p>
<h1 id="rfc.section.5.4.4">
<a href="#rfc.section.5.4.4">5.4.4.</a> ECVRF Decode Proof</h1>
<p id="rfc.section.5.4.4.p.1">ECVRF_decode_proof(pi_string) </p>
<p id="rfc.section.5.4.4.p.2">Input: </p>

<ul class="empty"><li>pi_string - VRF proof, octet string (m+3n octets)</li></ul>

<p> </p>
<p id="rfc.section.5.4.4.p.3">Output: </p>

<ul class="empty">
<li>"INVALID", or </li>
<li>Gamma - EC point</li>
<li>c - integer between 0 and 2^(8n)-1 </li>
<li>s - integer between 0 and 2^(16n)-1 </li>
</ul>

<p> </p>
<p id="rfc.section.5.4.4.p.4">Steps: </p>

<ol>
<li>let gamma_string, c_string, s_string be pi_string split after m-th and m+n-th octet</li>
<li>Gamma = string_to_point(gamma_string)</li>
<li>if Gamma = "INVALID" output "INVALID" and stop.</li>
<li>c = string_to_int(c_string)</li>
<li>s = string_to_int(s_string)</li>
<li>Output Gamma, c, and s</li>
</ol>

<p> </p>
<h1 id="rfc.section.5.5">
<a href="#rfc.section.5.5">5.5.</a> <a href="#suites" id="suites">ECVRF Ciphersuites</a>
</h1>
<p id="rfc.section.5.5.p.1">This document defines ECVRF-P256-SHA256 as follows: [TODO: rename this one by adding some kind of suffix to indicate try-and-increment, to avoid possibility of confusion with -SWU version?] </p>

<ul>
<li>suite_string = 0x01 = int_to_string(1, 1). </li>
<li>The EC group G is the NIST-P256 elliptic curve, with curve parameters as specified in <a href="#FIPS-186-3" class="xref">[FIPS-186-3]</a> (Section D.1.2.3) and <a href="#RFC5114" class="xref">[RFC5114]</a>  (Section 2.6). For this group, 2n = 32 and cofactor = 1.  </li>
<li>The key pair generation primitive is specified in Section 3.2.1 of <a href="#SECG1" class="xref">[SECG1]</a> (q, B, SK, and PK in this document correspond to in n, G, d, and Q in Section 3.2.1 of <a href="#SECG1" class="xref">[SECG1]</a>).  In this ciphersuite, the secret scalar x is equal to the private key SK.  </li>
<li>The ECVRF_nonce_generation function is as specified in <a href="#nonceP256" class="xref">Section 5.4.2.1</a>.</li>
<li>The int_to_string function is the I2OSP function specified in Section 4.1 of <a href="#RFC8017" class="xref">[RFC8017]</a>. (This is big endian representation.)</li>
<li>The string_to_int function is the OS2IP function specified in Section 4.2 of <a href="#RFC8017" class="xref">[RFC8017]</a>. (This is big endian representation.)</li>
<li>The point_to_string function converts an EC point to an octet string according to the encoding specified in Section 2.3.3 of <a href="#SECG1" class="xref">[SECG1]</a> with point compression on.  This implies m = 2n + 1 = 33.  (Note that certain software implementations do not introduce a seperate elliptic curve point type and instead directly treat the EC point as an octet string per above encoding. When using such an implementation, the point_to_string function can be treated as the identity function.) </li>
<li>The string_to_point function converts an octet string to an EC point according to the encoding specified in Section 2.3.4 of <a href="#SECG1" class="xref">[SECG1]</a>. This function MUST output INVALID if the octet string does not decode to an EC point.  </li>
<li>arbitrary_string_to_point(h_string) = string_to_point(0x02 || h_string) (where 0x02 is a single octet with value 2, 0x02=int_to_string(2, 1)). The input h_string is a 32-octet string and the output is either an EC point or "INVALID". </li>
<li>The hash function Hash is SHA-256 as specified in <a href="#RFC6234" class="xref">[RFC6234]</a>.  </li>
<li>The ECVRF_hash_to_curve function is as specified in <a href="#ecvrfH2C1" class="xref">Section 5.4.1.1</a>.  </li>
</ul>

<p> </p>
<p id="rfc.section.5.5.p.2">This document defines ECVRF-P256-SHA256-SWU as follows: </p>

<ul><li>This ciphersuite is identical to ECVRF-P256-SHA256 except that the ECVRF_hash_to_curve function is as specified in <a href="#SimpleSWU" class="xref">Section 5.4.1.3</a> and suite_string = 0x02 = int_to_string(2, 1).  </li></ul>

<p> </p>
<p id="rfc.section.5.5.p.3">This document defines ECVRF-ED25519-SHA512 as follows: [TODO: rename this one by adding some kind of suffix to indicate try-and-increment, to avoid possibility of confusion with -Elligator version?] </p>

<ul>
<li>suite_string = 0x03 = int_to_string(3, 1). </li>
<li>The EC group G is the Ed25519 elliptic curve with parameters defined in Table 1 of <a href="#RFC8032" class="xref">[RFC8032]</a>.  For this group, 2n = 32 and cofactor = 8.  </li>
<li>The private key and generation of the secret scalar and the public key are specified in Section 5.1.5 of <a href="#RFC8032" class="xref">[RFC8032]</a>
</li>
<li>The ECVRF_nonce_generation function is as specified in <a href="#nonce25519" class="xref">Section 5.4.2.2</a>.</li>
<li>The int_to_string function as specified in the first paragraph of Section 5.1.2 of <a href="#RFC8032" class="xref">[RFC8032]</a>. (This is little endian representation.)</li>
<li>The string_to_int function interprets the string as an integer in little-endian representation.</li>
<li>The point_to_string function converts an EC point to an octect string according to the encoding specified in Section 5.1.2 of <a href="#RFC8032" class="xref">[RFC8032]</a>.  This implies m = 2n = 32.  (Note that certain software implementations do not introduce a seperate elliptic curve point type and instead directly treat the EC point as an octet string per above encoding. When using such and implementation, the point_to_string function can be treated as the identity function.) </li>
<li>The string_to_point function converts an octet string to an EC point according to the encoding specified in Section 5.1.3 of <a href="#RFC8032" class="xref">[RFC8032]</a>.  This function MUST output INVALID if the octet string does not decode to an EC point.  </li>
<li>arbitrary_string_to_point function is equivalent to the string_to_point function.</li>
<li>The hash function Hash is SHA-512 as specified in <a href="#RFC6234" class="xref">[RFC6234]</a>.  </li>
<li>The ECVRF_hash_to_curve function is as specified in <a href="#ecvrfH2C1" class="xref">Section 5.4.1.1</a>.  </li>
</ul>

<p> </p>
<p id="rfc.section.5.5.p.4">This document defines ECVRF-ED25519-SHA512-Elligator2 as follows: </p>

<ul><li>This ciphersuite is identical to ECVRF-ED25519-SHA512 except that the ECVRF_hash_to_curve function is as specified in <a href="#elligator2" class="xref">Section 5.4.1.2</a> and suite_string = 0x04 = int_to_string(4, 1).  </li></ul>

<p> </p>
<h1 id="rfc.section.5.6">
<a href="#rfc.section.5.6">5.6.</a> <a href="#keycheck" id="keycheck">When the ECVRF Keys are Untrusted</a>
</h1>
<p id="rfc.section.5.6.p.1">The ECVRF as specified above is a VRF that satisfies the "trusted uniqueness", "trusted collision resistance", and "full pseudorandomness" properties defined in <a href="#secdef" class="xref">Section 3</a>.  In order to obtain "full uniqueness" and "full collision resistance" (which provide protection against a malicious VRF public key), the Verifier MUST perform the following additional validation procedure upon receipt of the public VRF key. The public VRF key MUST NOT be used if this procedure returns "INVALID".  </p>
<p id="rfc.section.5.6.p.2">Note that this procedure is not sufficient if the elliptic curve E or the point B, the generator of group G, is untrusted. If the prover is untrusted, the Verifier MUST obtain E and B from a trusted source, such as a ciphersuite specification, rather than from the prover.  </p>
<p id="rfc.section.5.6.p.3">This procedure supposes that the public key provided to the Verifier is an octet string. The procedure returns "INVALID" if the public key in invalid.  Otherwise, it returns Y, the public key as an EC point.  </p>
<h1 id="rfc.section.5.6.1">
<a href="#rfc.section.5.6.1">5.6.1.</a> ECVRF Validate Key</h1>
<p id="rfc.section.5.6.1.p.1">ECVRF_validate_key(PK_string) </p>
<p id="rfc.section.5.6.1.p.2">Input: </p>

<ul class="empty"><li>PK_string - public key, an octet string</li></ul>

<p> </p>
<p id="rfc.section.5.6.1.p.3">Output: </p>

<ul class="empty">
<li>"INVALID", or </li>
<li>Y - public key, an EC point</li>
</ul>

<p> </p>
<p id="rfc.section.5.6.1.p.4">Steps: </p>

<ol>
<li>Y = string_to_point(PK_string)</li>
<li>If Y is "INVALID", output "INVALID" and stop</li>
<li>If cofactor*Y is the EC point at infinty, output "INVALID" and stop</li>
<li>Output Y</li>
</ol>

<p> </p>
<p id="rfc.section.5.6.1.p.5">Note that if the cofactor = 1, then Step 3 need not multiply Y by the cofactor; instead, it suffices to output "INVALID" if Y is the point at infinity. Moreover, if the cofactor is small, the total number of points that could cause Step 3 to output "INVALID" may be small, and it may be more efficient to simply check Y against a fixed list of such points. For example, the following algorithm can be used for the Ed25519 curve: </p>

<ol>
<li>Y = string_to_point(PK_string)</li>
<li>If Y is "INVALID", output "INVALID" and stop</li>
<li>y_string = PK_string</li>
<li>oneTwentySeven_string = 0x7F = int_to_string(127, 1) <br>(a single octet with value 127)</li>
<li>y_string[31] = y_string[31] &amp; oneTwentySeven_string <br>(this step clears the high-order bit of octet 31)</li>
<li>bad_pk[0] = int_to_string(0, 32)</li>
<li>bad_pk[1] = int_to_string(1, 32)</li>
<li>bad_y2 = 2707385501144840649318225287225658788936804267575313519463743609750303402022</li>
<li>bad_pk[2] = int_to_string(bad_y2, 32)</li>
<li>bad_pk[3] = int_to_string(p-bad_y2, 32)</li>
<li>bad_pk[4] = int_to_string(p-1, 32)</li>
<li>bad_pk[5] = int_to_string(p, 32)</li>
<li>bad_pk[6] = int_to_string(p+1, 32)</li>
<li>If y_string is in bad_pk[0]...bad_pk[6], output "INVALID" and stop</li>
<li>Output Y</li>
</ol>

<p> (bad_pk[0], bad_pk[2], bad_pk[3] each match two bad public keys, depending on the sign of the x-coordinate, which was cleared in step 5, in order to make sure that it does not affect the comparison. bad_pk[1] and bad_pk[4] each match one bad public key, because x-coordinate is 0 for these two public keys. bad_pk[5] and bad_pk[6] are simply bad_pk[0] and bad_pk[1] shifted by p, in case the y-coordinate had not been modular reduced. There is no need to shift the other bad_pk values by p, because they will exceed 2^255.) [TODO: what's the sources for these? We got them from libsodium  https://github.com/jedisct1/libsodium/blob/cfb0f94704841f943a5a11d9e335da409c55d58a/src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c#L1003 but not sure if it's the original] </p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#imp" id="imp">Implementation Status</a>
</h1>
<p id="rfc.section.6.p.1">[TODO: Needs Updating; include also implementations of various parts, so developers can access them]</p>
<p id="rfc.section.6.p.2">An implementation of the RSA-FDH-VRF (SHA-256) and ECVRF-P256-SHA256 was first developed as a part of the NSEC5 project <a href="#I-D.vcelak-nsec5" class="xref">[I-D.vcelak-nsec5]</a> and is available at <span>&lt;</span><a href="http://github.com/fcelda/nsec5-crypto">http://github.com/fcelda/nsec5-crypto</a><span>&gt;</span>.  The ECVRF implementation may be out of date as this spec has evolved.  </p>
<p id="rfc.section.6.p.3">The Key Transparency project at Google uses a VRF implemention that is similar to the ECVRF-P256-SHA256, with a few minor changes including the use of SHA-512 instead of SHA-256. Its implementation is available <span>&lt;</span><a href="https://github.com/google/keytransparency/blob/master/core/vrf/vrf.go">https://github.com/google/keytransparency/blob/master/core/vrf/vrf.go</a><span>&gt;</span> </p>
<p id="rfc.section.6.p.4">An implementation by Yahoo! similar to the ECVRF is available at <span>&lt;</span><a href="https://github.com/r2ishiguro/vrf">https://github.com/r2ishiguro/vrf</a><span>&gt;</span>.  </p>
<p id="rfc.section.6.p.5">An implementation similar to ECVRF is available as part of the CONIKS implementation in Golang at <span>&lt;</span><a href="https://github.com/coniks-sys/coniks-go/tree/master/crypto/vrf">https://github.com/coniks-sys/coniks-go/tree/master/crypto/vrf</a><span>&gt;</span>.  </p>
<p id="rfc.section.6.p.6">Open Whisper Systems also uses a VRF very similar to ECVRF-ED25519-SHA512-Elligator, called VXEdDSA, and specified here: <span>&lt;</span><a href="https://whispersystems.org/docs/specifications/xeddsa/">https://whispersystems.org/docs/specifications/xeddsa/</a><span>&gt;</span> </p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#securitycons" id="securitycons">Security Considerations</a>
</h1>
<h1 id="rfc.section.7.1">
<a href="#rfc.section.7.1">7.1.</a> Key Generation</h1>
<p id="rfc.section.7.1.p.1">Applications that use the VRFs defined in this document MUST ensure that that the VRF key is generated correctly, using good randomness.  </p>
<h1 id="rfc.section.7.1.1">
<a href="#rfc.section.7.1.1">7.1.1.</a> Uniqueness and collision resistance with untrusted keys</h1>
<p id="rfc.section.7.1.1.p.1">The ECVRF as specified in <a href="#ecvrfprove" class="xref">Section 5.1</a>-<a href="#suites" class="xref">Section 5.5</a> statisfies the "trusted uniqueness" and "trusted collision resistance" properties as long as the VRF keys are generated correctly, with good randomness.  If the Verifier trusts the VRF keys are generated correctly, it MAY use the public key Y as is.  </p>
<p id="rfc.section.7.1.1.p.2">However, if the ECVRF uses keys that could be generated adversarially, then the the Verfier MUST first perform the validation procedure ECVRF_validate_key(PK) (specified in <a href="#keycheck" class="xref">Section 5.6</a>)  upon receipt of the public key PK as an octet string.  If the validation procedure outputs "INVALID", then the public key MUST not be used.  Otherwise, the procedure will output a valid public key Y, and the ECVRF with public key Y satisfies the "full uniqueness" and "full collision resistance" properties.  </p>
<p id="rfc.section.7.1.1.p.3">The RSA-FDH-VRF statisfies the "trusted uniqueness" and "trusted collision resistance" properties as long as the VRF keys are generated correctly, with good randomness.  These properties may not hold if the keys are generated adversarially (e.g., if RSA is not permutation). Meanwhile, the "full uniqueness" and "full collision resistance" are properties that hold  even if VRF keys are generated by an adversary.  The RSA-FDH-VRF defined in this document does not have these properties.  However, if adversarial key generation is a concern, the RSA-FDH-VRF may be modifed to have these properties by adding additional cryptographic checks that its public key has the right form.  These modifications are left for future specification.  </p>
<h1 id="rfc.section.7.1.2">
<a href="#rfc.section.7.1.2">7.1.2.</a> Pseudorandomness with untrusted keys</h1>
<p id="rfc.section.7.1.2.p.1">Without good randomness, the "pseudorandomness" properties of the VRF may not hold. Note that it is not possible to guarantee pseudorandomness in the face of adversarially generated VRF keys.  This is because an adversary can always use bad randomness to generate the VRF keys, and thus, the VRF output may not be pseudorandom.  </p>
<h1 id="rfc.section.7.2">
<a href="#rfc.section.7.2">7.2.</a> Selective vs Full Pseudorandomness</h1>
<p><a href="#nsec5ecc" class="xref">[nsec5ecc]</a> presents cryptographic reductions to an underlying hard problem (e.g. Decisional Diffie Hellman for the ECVRF, or the standard RSA assumption for RSA-FDH-VRF) that prove the VRFs specificied in this document possess full pseudorandomness as well as selective pseudorandomness.  However, the cryptographic reductions are tighter for selective pseudorandomness than for full pseudorandomness.  This means the the VRFs have quantitavely stronger security guarentees for selective pseudorandomness.  </p>
<p id="rfc.section.7.2.p.2">Applications that are concerned about tightness of cryptographic reductions therefore have two options.  </p>

<ul>
<li>They may choose to ensure that selective pseudorandomness is sufficient for the application. That is, that pseudorandomness of outputs matters only for inputs that are chosen independently of the VRF key.  </li>
<li>If full pseudorandomness is required for the application, the application may increase security parameters to make up for the loose security reduction.  For RSA-FDH-VRF, this means increasing the RSA key length. For ECVRF, this means increasing the cryptographic strength of the EC group G. For both RSA-FDH-VRF and ECVRF the cryptographic strength of the hash function Hash may also potentially need to be increased.  </li>
</ul>

<p> </p>
<h1 id="rfc.section.7.3">
<a href="#rfc.section.7.3">7.3.</a> Proper pseudorandom nonce for ECVRF</h1>
<p id="rfc.section.7.3.p.1">The security of the ECVRF defined in this document relies on the fact that nonce k used in the ECVRF_prove algorithm is chosen uniformly and pseudorandomly modulo q, and is unknown to the advesrary.  Otherwise, an adversary may be able to recover the private VRF key x (and thus break pseudorandomness of the VRF) after observing several valid VRF proofs pi. The nonce generation methods specified in the ECVRF ciphersuites of <a href="#suites" class="xref">Section 5.5</a> are designed with this requirement in mind.  </p>
<h1 id="rfc.section.7.4">
<a href="#rfc.section.7.4">7.4.</a> Side-channel attacks</h1>
<p id="rfc.section.7.4.p.1">Side channel attacks on cryptographic primatives are an important issue.  Here we discuss only one such side channel:  timing attacks that can be used to leak information about the VRF input alpha.  Implementers should take care to avoid side-channel attacks that leak information about the VRF private key SK (and the nonce k used in the ECVRF).</p>
<p id="rfc.section.7.4.p.2">The ECVRF_hash_to_curve_try_and_increment algorithm defined in <a href="#ecvrfH2C1" class="xref">Section 5.4.1.1</a> SHOULD NOT be used in applications where the VRF input alpha is secret and is hashed by the VRF on-the-fly.  This is because the algorithm's running time depends on the VRF input alpha, and thus creates a timing channel that can be used to learn information about alpha.  That said, for most inputs the amount of information obtained from such a timing attack is likely to be small (1 bit, on average), since the algorithm is expected to find a valid curve point after only two attempts.  However, there might be inputs which cause the algorithm to make many attempts before it finds a valid curve point; for such inputs, the information leaked in a timing attack will be more than 1 bit.  </p>
<p id="rfc.section.7.4.p.3">Meanwhile, ECVRF-ED25519-SHA512-Elligator2 runs in time constant in alpha if the implementation of the ECVRF_hash_to_curve function specified in <a href="#elligator2" class="xref">Section 5.4.1.2</a> also runs in constant time.  </p>
<h1 id="rfc.section.7.5">
<a href="#rfc.section.7.5">7.5.</a> Proofs Provide No Secrecy for VRF Input</h1>
<p id="rfc.section.7.5.p.1">The VRF proof pi is not designed to provide secrecy and, in general, may reveal the VRF input alpha.  Anyone who knows PK and pi is able to perform an offline dictionary attack to search for alpha, by verifying guesses for alpha using VRF_verify.  This is in contrast to the VRF hash output beta which, without the proof, is pseudorandom and thus is designed to reveal no information about alpha.  </p>
<h1 id="rfc.section.7.6">
<a href="#rfc.section.7.6">7.6.</a> <a href="#prehash" id="prehash">Prehashing</a>
</h1>
<p id="rfc.section.7.6.p.1">The VRFs specified in this document allow for read-once access to the input alpha for both signing and verifying. Thus, additional prehashing of alpha (as specified, for example, in <a href="#RFC8032" class="xref">[RFC8032]</a> for EdDSA signatures) is not needed, even for applications that need to handle long alpha or to support the Initialized-Update-Finalize (IUF) interface (in such an interface, alpha is not supplied all at once, but rather in pieces by a sequence of calls to Update).  The ECVRF, in particular, uses alpha only in ECVRF_hash_to_curve. The curve point H becomes the representative of alpha thereafter. Note that the suite_string octet and the public key are hashed together with alpha in ECVRF_hash_to_curve, which ensures that the curve (including the generator B) and the public key are included indirectly into subsequent hashes.</p>
<h1 id="rfc.section.7.7">
<a href="#rfc.section.7.7">7.7.</a> Hash function domain separation and future-proofing</h1>
<p id="rfc.section.7.7.p.1">Hashing is used for different purposes in the two VRFs (namely, in the RSA-FDH-VRF, in MGF1 and in proof_to_hash; in the ECVRF, in hash_to_curve, nonce_generation, hash_points, and proof_to_hash). The theoretical analysis assumes each of these functions is a separate random oracle.  This analysis still holds even if the same hash function is used, as long as the four queries made to the hash function for a given SK and alpha are overwhelmingly unlikely to equal each other or to any queries made to the hash function for the same SK and different alpha. This is indeed the case for the RSA-FDH-VRF defined in this document, because the first octets of the input to the hash function used in MGF1 and in proof_to_hash are different.  This is also the case for the ECVRF ciphersuites defined in this document, because: </p>

<ul>
<li>inputs to the hash function used during nonce_generation are unlikely to equal to inputs given to hash_to_curve, proof_to_hash, and hash_points. This follows since nonce_generation inputs a secret to the hash function that is not used by honest parties as input to any other hash function, and is not available to the adversary</li>
<li>the second octet of the input to the hash function used in hash_to_curve, proof_to_hash, and hash_points are all different</li>
</ul>

<p> </p>
<p id="rfc.section.7.7.p.2">For the RSA VRF, if future designs need to specify variants of the design in this document, such variants should use different first octets in inputs to MGF1 and to the hash funciton used in proof_to_hash, in order to avoid the possibility that an adversary can obtain a VRF output under one variant, and then claim it was obtained under another variant </p>
<p id="rfc.section.7.7.p.3">For the elliptic curve VRF, if future designs need to specify variants (e.g., additional ciphersuites) of the design in this document, then, to avoid the possibility that an adversary can obtain a VRF output under one variant, and then claim it was obtained under another variant, they should specify a different suite_string constant. This way, the inputs to the hash_to_curve hash function used in producing H are guaranteed to be different; since all the other hashing done by the prover depends on H, inputs all the hash functions used by the prover will also be different as long as hash_to_curve is collision resistant.  </p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> Change Log</h1>
<p id="rfc.section.8.p.1">Note to RFC Editor: if this document does not obsolete an existing RFC, please remove this appendix before publication as an RFC.  </p>
<p></p>

<ul class="empty">
<li>00 - Forked this document from draft-goldbe-vrf-01.</li>
<li>01 - Minor updates, mostly highlighting TODO items.</li>
<li>02 - Added specification of elligator2 for Curve25519, along with ciphersuites for ECVRF-ED25519-SHA512-Elligator.  Changed ECVRF-ED25519-SHA256 suite_string to ECVRF-ED25519-SHA512. (This change made because Ed25519 in <a href="#RFC8032" class="xref">[RFC8032]</a> signatures use SHA512 and not SHA256.) Made ECVRF nonce generation a separate component, so that nonces are determinsitic.  In ECVRF proving, changed + to - (and made corresponding verification changes) in order to be consistent with EdDSA and ECDSA.  Highlighted that ECVRF_hash_to_curve acts like a prehash.  Added "suites" variable to ECVRF for future-proofing.  Ensured domain separation for hash functions by modifying hash_points and added discussion about domain separation.  Updated todos in the "additional pseudorandomness property" section. Added an discussion of secrecy into security considerations.  Removed B and PK=Y from ECVRF_hash_points because they are already present via H, which is computed via hash_to_curve using the suite_string (which identifies B) and Y.</li>
<li>03 - Changed Ed25519 conversions to little-endian, to match RFC 8032;  added simple key validation for Ed25519; added Simple SWU cipher suite; clarified Elligator; added domain separation for RSA VRF; improved notation throughout; added nonce generation as a section</li>
</ul>

<p> </p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> Contributors</h1>
<p id="rfc.section.9.p.1">This document also would not be possible without the work of Moni Naor (Weizmann Institute), Sachin Vasant (Cisco Systems), and Asaf Ziv (Facebook).  Shumon Huque, David C. Lawerence, Trevor Perrin, Annie Yousar, Stanislav Smyshlyaev, Liliya Akhmetzyanova, Tony Arcieri, Sergey Gorbunov, Sam Scott, Nick Sullivan, Christopher Wood, Marek Jankowski, Derek Ting-Haye Leung, Adam Suhl, and Gary Belvin provided valuable input to this draft. [TODO: Add more people who commented] </p>
<h1 id="rfc.references">
<a href="#rfc.references">10.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">10.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="FIPS-186-3">[FIPS-186-3]</b></td>
<td class="top">
<a>National Institute for Standards and Technology</a>, "<a>Digital Signature Standard (DSS)</a>", FIPS PUB 186-3, June 2009.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5114">[RFC5114]</b></td>
<td class="top">
<a>Lepinski, M.</a> and <a>S. Kent</a>, "<a href="https://tools.ietf.org/html/rfc5114">Additional Diffie-Hellman Groups for Use with IETF Standards</a>", RFC 5114, DOI 10.17487/RFC5114, January 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6234">[RFC6234]</b></td>
<td class="top">
<a>Eastlake 3rd, D.</a> and <a>T. Hansen</a>, "<a href="https://tools.ietf.org/html/rfc6234">US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)</a>", RFC 6234, DOI 10.17487/RFC6234, May 2011.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6979">[RFC6979]</b></td>
<td class="top">
<a>Pornin, T.</a>, "<a href="https://tools.ietf.org/html/rfc6979">Deterministic Usage of the Digital Signature Algorithm (DSA) and Elliptic Curve Digital Signature Algorithm (ECDSA)</a>", RFC 6979, DOI 10.17487/RFC6979, August 2013.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8017">[RFC8017]</b></td>
<td class="top">
<a>Moriarty, K.</a>, <a>Kaliski, B.</a>, <a>Jonsson, J.</a> and <a>A. Rusch</a>, "<a href="https://tools.ietf.org/html/rfc8017">PKCS #1: RSA Cryptography Specifications Version 2.2</a>", RFC 8017, DOI 10.17487/RFC8017, November 2016.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8032">[RFC8032]</b></td>
<td class="top">
<a>Josefsson, S.</a> and <a>I. Liusvaara</a>, "<a href="https://tools.ietf.org/html/rfc8032">Edwards-Curve Digital Signature Algorithm (EdDSA)</a>", RFC 8032, DOI 10.17487/RFC8032, January 2017.</td>
</tr>
<tr>
<td class="reference"><b id="SECG1">[SECG1]</b></td>
<td class="top">
<a>Standards for Efficient Cryptography Group (SECG)</a>, "<a href="http://www.secg.org/sec1-v2.pdf">SEC 1: Elliptic Curve Cryptography</a>", Version 2.0, May 2009.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">10.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="BCIMRT10">[BCIMRT10]</b></td>
<td class="top">
<a>Brier, E.</a>, <a>Coron, J.</a>, <a>Icart, T.</a>, <a>Madore, D.</a>, <a>Randriam, H.</a> and <a>M. Tibouchi</a>, "<a>Efficient Indifferentiable Hashing into Ordinary Elliptic Curves</a>", in CRYPTO, 2010.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.vcelak-nsec5">[I-D.vcelak-nsec5]</b></td>
<td class="top">
<a>Vcelak, J.</a>, <a>Goldberg, S.</a>, <a>Papadopoulos, D.</a>, <a>Huque, S.</a> and <a>D. Lawrence</a>, "<a href="https://tools.ietf.org/html/draft-vcelak-nsec5-07">NSEC5, DNSSEC Authenticated Denial of Existence</a>", Internet-Draft draft-vcelak-nsec5-07, June 2018.</td>
</tr>
<tr>
<td class="reference"><b id="Icart09">[Icart09]</b></td>
<td class="top">
<a>Icart, T.</a>, "<a>How to Hash into Elliptic Curves</a>", in CRYPTO, 2009.</td>
</tr>
<tr>
<td class="reference"><b id="MRV99">[MRV99]</b></td>
<td class="top">
<a>Michali, S.</a>, <a>Rabin, M.</a> and <a>S. Vadhan</a>, "<a>Verifiable Random Functions</a>", in FOCS, 1999.</td>
</tr>
<tr>
<td class="reference"><b id="nsec5ecc">[nsec5ecc]</b></td>
<td class="top">
<a>Papadopoulos, D.</a>, <a>Wessels, D.</a>, <a>Huque, S.</a>, <a>Vcelak, J.</a>, <a>Naor, M.</a>, <a>Reyzin, L.</a> and <a>S. Goldberg</a>, "<a href="https://eprint.iacr.org/2017/099.pdf">Making NSEC5 Practical for DNSSEC</a>", in ePrint Cryptology Archive 2017/099, February 2017.</td>
</tr>
<tr>
<td class="reference"><b id="ntb">[ntb]</b></td>
<td class="top">
<a>Shoup, V.</a>, "<a href="http://www.shoup.net/ntb/ntb-v2.pdf">A Computational Introduction to Number Theory and Algebra</a>", 2008.</td>
</tr>
<tr>
<td class="reference"><b id="SW18">[SW18]</b></td>
<td class="top">
<a>Sullivan, E.</a> and <a>C. Wood</a>, "<a>Hashing to Elliptic Curves</a>", 2018.</td>
</tr>
</tbody></table>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Sharon Goldberg</span> 
	  <span class="n hidden">
		<span class="family-name">Goldberg</span>
	  </span>
	</span>
	<span class="org vcardline">Boston University</span>
	<span class="adr">
	  <span class="vcardline">111 Cummington St, MCS135</span>

	  <span class="vcardline">
		<span class="locality">Boston</span>,  
		<span class="region">MA</span> 
		<span class="code">02215</span>
	  </span>
	  <span class="country-name vcardline">USA</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:goldbe@cs.bu.edu">goldbe@cs.bu.edu</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Leonid Reyzin</span> 
	  <span class="n hidden">
		<span class="family-name">Reyzin</span>
	  </span>
	</span>
	<span class="org vcardline">Boston University</span>
	<span class="adr">
	  <span class="vcardline">111 Cummington St, MCS135</span>

	  <span class="vcardline">
		<span class="locality">Boston</span>,  
		<span class="region">MA</span> 
		<span class="code">02215</span>
	  </span>
	  <span class="country-name vcardline">USA</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:reyzin@bu.edu">reyzin@bu.edu</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Dimitrios Papadopoulos</span> 
	  <span class="n hidden">
		<span class="family-name">Papadopoulos</span>
	  </span>
	</span>
	<span class="org vcardline">Hong Kong University of Science and Techology</span>
	<span class="adr">
	  <span class="vcardline">Clearwater Bay</span>

	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Hong Kong</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:dipapado@cse.ust.hkbu.edu">dipapado@cse.ust.hkbu.edu</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Jan Vcelak</span> 
	  <span class="n hidden">
		<span class="family-name">Vcelak</span>
	  </span>
	</span>
	<span class="org vcardline">NS1</span>
	<span class="adr">
	  <span class="vcardline">16 Beaver St</span>

	  <span class="vcardline">
		<span class="locality">New York</span>,  
		<span class="region">NY</span> 
		<span class="code">10004</span>
	  </span>
	  <span class="country-name vcardline">USA</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:jvcelak@ns1.com">jvcelak@ns1.com</a></span>

  </address>
</div>

</body>
</html>
